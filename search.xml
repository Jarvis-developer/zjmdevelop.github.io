<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2018/05/25/AutoLayout%E7%9A%84%E5%8E%9F%E7%90%86%E6%80%A7%E8%83%BD/"/>
      <url>/2018/05/25/AutoLayout%E7%9A%84%E5%8E%9F%E7%90%86%E6%80%A7%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>Auto Layout ，是苹果公司提供的一个基于约束布局，动态计算视图大小和位置的库，并且已经集成到了 Xcode 开发环境里。但是Auto Layout的具体的性能跟易用性到底如何呢,咱们详细的分析一下!</p><a id="more"></a><p>在引入 Auto Layout 这种自动布局方式之前，iOS 开发都是采用手动布局的方式。而手动布局的方式，原始落后、界面开发维护效率低. 所以，苹果需要提供更好的界面引擎来提升开发者的体验，Auto Layout 随之出现。</p><p>苹果公司早在 iOS 6 系统时就引入了 Auto Layout，但是直到现在还有很多开发者迟迟不愿使用 它，其原因就在于对其性能的担忧。即使后来，苹果公司推出了在 Auto Layout 基础上模仿前端 Flexbox 布局思路的 UIStackView 工具，提高了开发体验和效率，也无法解除开发者们对其性能的顾虑。</p><h4 id="1-Auto-Layout-到底是如何实现自动布局的，这种布局算法真的会影响性能吗？"><a href="#1-Auto-Layout-到底是如何实现自动布局的，这种布局算法真的会影响性能吗？" class="headerlink" title="1. Auto Layout 到底是如何实现自动布局的，这种布局算法真的会影响性能吗？"></a>1. Auto Layout 到底是如何实现自动布局的，这种布局算法真的会影响性能吗？</h4><h4 id="2-Apple在-WWDC-2018-中介绍说：-iOS-12-将大幅提高-Auto-Layout-性能，使滑动达到满帧，这是如何做到的呢？"><a href="#2-Apple在-WWDC-2018-中介绍说：-iOS-12-将大幅提高-Auto-Layout-性能，使滑动达到满帧，这是如何做到的呢？" class="headerlink" title="2. Apple在 WWDC 2018 中介绍说： iOS 12 将大幅提高 Auto Layout 性能，使滑动达到满帧，这是如何做到的呢？"></a>2. Apple在 WWDC 2018 中介绍说： iOS 12 将大幅提高 Auto Layout 性能，使滑动达到满帧，这是如何做到的呢？</h4><h4 id="3-我们应该选择继续手动布局还是选择-Auto-Layout-呢？"><a href="#3-我们应该选择继续手动布局还是选择-Auto-Layout-呢？" class="headerlink" title="3. 我们应该选择继续手动布局还是选择 Auto Layout 呢？"></a>3. 我们应该选择继续手动布局还是选择 Auto Layout 呢？</h4><p>就着这三个问题，我们就来详细聊聊 Auto Layout 吧。</p><p>Auto Layout的来历:</p><ol><li>1997年AutoLayout用到的布局算法Cassowary被发明出来.</li><li>2011年,Apple将Cassowary算法用到了自家的布局引擎AutoLayout中.</li></ol><p>Cassowary 能够有效解析线性等式系统和线性不等式系统，用来表示用户界面的相等和相对关系。基于此，Cassowary 制定了一种规则，通过约束来描述视图间的关系。这个规则能够表示出一个视图相对于另一个视图的位置。Cassowary 算法让视图布局通过相对位置简化，简单的相对位置描述可以在运行时动态地计算出视图具体的位置。视图位置的写法简化了，界面相关代码也就更易于维护。简单来说, Cassowary通过将布局问题抽象成线性不等式，并分解成多个位置间的约束，解决了用户界面的布局问题.苹果公司也是看重了这一点，将其引入到了自己的系统中。</p><p>Auto Layout 不只有布局算法 Cassowary，还包含了布局在运行时的生命周期等一整套布局引擎系统，用来统一管理布局的创建、更新和销毁。了解 Auto Layout 的生命周期，是理解它的性能相关话题的基础。这样，在遇到问题，特别是性能问题时，我们才能从根儿上找到原因，从而避免或改进类似的问题。</p><p>这一整套布局引擎系统叫作 Layout Engine ，是 Auto Layout 的核心，主导着整个界面布局。<br>每个视图在得到自己的布局之前，Layout Engine 会将视图、约束、优先级、固定大小通过计算转换成最终的大小和位置。在 Layout Engine 里，每当约束发生变化，就会触发 Deferred Layout Pass，完成后进入监听约束变化的状态。当再次监听到约束变化，即进入下一轮循环中。整个过程如下图所示：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4kfh6gd1sj31410u0teh.jpg" alt="Layout Engine 界面布局过程"></p><center>Layout Engine 界面布局过程</center><p>图中， Constraints Change 表示的就是约束变化，添加、删除视图时会触发约束变化。Activating 或 Deactivating，设置 Constant 或 Priority 时也会触发约束变化。Layout Engine 在碰到约束变化后会重新计算布局，获取到布局后调用 superview.setNeedLayout()，然后进入 Deferred Layout Pass。Deferred Layout Pass 的主要作用是做容错处理。如果有些视图在更新约束时没有确定或缺失布局声明的话，会先在这里做容错处理。</p><p>接下来，Layout Engine 会从上到下调用 layoutSubviews() ，通过 Cassowary 算法计算各个子视图的位置，算出来后将子视图的 frame 从 Layout Engine 里拷贝出来。在这之后的处理，就和手写布局的绘制、渲染过程一样了。所以，使用 Auto Layout 和手写布局的区别，就是多了布局上的这个计算过程。</p><p>那么，多的这个 Cassowary 布局，就是在 iOS 12 之前影响 Auto Layout 性能的原因吗？<br>接下来，我就跟你分析下 Auto Layout 的性能问题。Auto Layout 的性能是否有问题，我们先看看苹果公司自己是怎么说的吧。<br><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4ldetnvirj31u90u0dgg.jpg" alt="Auto Layout 在 iOS 12 中优化后的表现"></p><center>Auto Layout 在 iOS 12 中优化后的表现</center><p>上图是 WWDC 2018 中 202 Session 里讲到的 Auto Layout 在 iOS 12 中优化后的表现。可以看到，优化后的性能，已经基本和手写布局一样可以达到性能随着视图嵌套的数量呈线性增长了。而在此之前的 Auto Layout，视图嵌套的数量对性能的影响是呈指数级增长的。所以 Auto Layout 对性能影响能大不大呢。但是，这个锅应该由 Cassowary 算法来背吗？<br>在 1997 年时，Cassowary 是以高效的界面线性方程求解算法被提出来的。它解决的是界面的线性规划问题，而线性规划问题的解法是 Simplex 算法。单从 Simplex 算法的复杂度来看，多数情况下是没有指数时间复杂度的。而 Cassowary 算法又是在 Simplex 算法基础上对界面关系方程进行了高效的添加、修改更新操作，不会带来时间复杂度呈指数级增长的问题。<br>那么，如果 Cassowary 算法本身没有问题的话，问题就只可能是苹果公司在 iOS 12 之前在某些情况下没有用好这个算法。<br>接下来，我们再看一下 WWDC 2018 中 202 Session 的 Auto Layout 在兄弟视图独立开布局的情况。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4ldezdcmsj31ts0u03z7.jpg" alt="Auto Layout 在兄弟视图独立开布局的情况"></p><center>AAuto Layout 在兄弟视图独立开布局的情况</center><p>可以看到，兄弟视图之间没有关系时，是不会出现性能呈指数增加问题的。这就表示 Cassowary 算法在添加时是高效的。但如果兄弟视图间有关系的话，在视图遍历时会不断处理和兄弟视图间的关系，这时会有修改更新计算。由此可以看出，Auto Layout 并没有用上 Cassowary 高效修改更新的特性。</p><p>实际情况是，iOS 12 之前，很多约束变化时都会重新创建一个计算引擎 NSISEnginer 将约束关系重新加进来，然后重新计算。结果就是，涉及到的约束关系变多时，新的计算引擎需要重新计算，最终导致计算量呈指数级增加。更详细的讲解，你可以参考 WWDC 2018 中 202 Session 的内容，里面完整地分析了以前的问题，以及 iOS12 的解法。总体来说， iOS12 的 Auto Layout 更多地利用了 Cassowary 算法的界面更新策略，使其真正完成了高效的界面线性策略计算。</p><p>那么，明确了 iOS 12 使得 Auto Layout 具有了和手写布局几乎相同的高性能后，你是不是就可以放心地使用 Auto Layout 了呢？ 答案是肯定的。</p><p>如果你是一名手写布局的 iOS 开发者，这是你投入 Auto Layout 布局开发的最佳时机。<br>使用 Auto Layout 一定要注意多使用 Compression Resistance Priority 和 Hugging Priority，利用优先级的设置，让布局更加灵活，代码更少，更易于维护。</p><p>Auto Layout 只是一种最基础的布局思路。在前端出现了 Flexbox 这种高级的响应式布局思路后，苹果公司也紧跟其后，基于 Auto Layout 又封装了一个类似 Flexbox 的 UIStackView，用来提高 iOS 开发响应式布局的易用性。UIStackView 会在父视图里设置子视图的排列方式，比如 Fill、Leading、Center，而不用在每个子视图中都设置自己和兄弟视图的关系，可以极大地减少你在约束关系设置上所做的重复工作，提升页面布局的体验。</p>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 技术细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 自动布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内存分配</title>
      <link href="/2018/05/18/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2018/05/18/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>从事iOS开发这么久了,其实很多东西是值得写下来的. 一方面是可以增加自己的理解深度,   另一方面可以让别人看到查漏补缺. 今天来简单的梳理一下iOS开发中的内存分配(不是内存管理哦😯), 是从系统方面的理解而不是数据结构方面的.</p><a id="more"></a><h3>应用的内存分区</h3><p>用一张图片来解释这个概念会更直观:</p><p><img src="https://upload-images.jianshu.io/upload_images/970779-efa594531d450226.png" alt="应用内存分区"></p><p>应用程序的内存分配主要分为5个区, 咱们从低地址向高地址叙述, 分别是:</p><h5 id="1-代码区"><a href="#1-代码区" class="headerlink" title="1.代码区"></a><a href="#1">1.代码区</a></h5><h5 id="2-常量区"><a href="#2-常量区" class="headerlink" title="2.常量区"></a><a href="#2">2.常量区</a></h5><h5 id="3-全局-静态-区"><a href="#3-全局-静态-区" class="headerlink" title="3.全局(静态)区"></a><a href="#3">3.全局(静态)区</a></h5><h5 id="4-堆区"><a href="#4-堆区" class="headerlink" title="4.堆区"></a><a href="#4">4.堆区</a></h5><h5 id="5-栈区"><a href="#5-栈区" class="headerlink" title="5.栈区"></a><a href="#5">5.栈区</a></h5><h5 id="堆-heap-和栈-stack-的几个区别"><a href="#堆-heap-和栈-stack-的几个区别" class="headerlink" title="堆(heap)和栈(stack)的几个区别:"></a><a href="#6">堆(heap)和栈(stack)的几个区别:</a></h5><h5 id="在Swift中的使用"><a href="#在Swift中的使用" class="headerlink" title="在Swift中的使用:"></a><a href="#7">在Swift中的使用:</a></h5><p>下面是对这几个区的详细解释:</p><h4 id="1">1.代码区:</h4><p>代码区是用来存放可执行文件的操作指令（存放函数的二进制代码, 也就是说是它是可执行程序在内存种的镜像。代码段需要防止在运行时被非法修改, 所以只准许读取操作, 而不允许写入（修改）操作——它是不可写的。</p><h4 id="1">2.常量区:</h4><p>常量存储区,   这是一块比较特殊的存储区,他们里面存放的是常量</p><h4 id="3">3.全局(静态)区:</h4><ul><li><p>数据区：数据段用来存放可执行文件中已初始化全局变量,换句话说就是存放程序静态分配的变量和全局变量。</p></li><li><p>BSS区：BSS段包含了程序中未初始化全局变量</p></li></ul><h4 id="4">4.堆区:</h4><p>堆是由<strong>程序员</strong>分配和释放,   用于存放进程运行中被动态分配的内存段,   它大小并不固定,   可动态扩张或缩减。当进程调用alloc等函数分配内存时,  新分配的内存就被动态添加到堆上（堆被扩张)；当利用realse释放内存时,   被释放的内存从堆中被剔除(堆被缩减）,   因为我们现在iOS基本都使用ARC来管理对象,   所以不用我们程序员来管理, 但是我们要知道这个对象存储的位置。</p><h4 id="5">5.栈区:</h4><p>栈是由<strong>编译器</strong>自动分配并释放,   用户存放程序临时创建的局部变量,   存放函数的参数值,   局部变量等。也就是说我们函数括弧<code>{}</code>中定义的变量（但不包括<code>static</code>声明的变量,   <code>static</code>意味这在数据段中存放变量. 除此以外在函数被调用时,   其参数也会被压入发起调用的进程栈中,   并且待到调用结束后,  函数的返回值也回被存放回栈中。由于栈的先进后出特点,   所以栈特别方便用来保存/恢复调用现场。从这个意义上将我们可以把栈看成一个临时数据寄存、交换的内存区。栈是向低地址扩展的数据结构,  是一块连续的内存的区域。堆是向高地址扩展的数据结构,   是不连续的内存区域。有人会问堆和栈会不会碰到一起,   他们之间间隔很大,   绝少有机会能碰到一起,   况且堆是链表方式存储！</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">8</span>;<span class="comment">//全局初始化区（数据区）</span></span><br><span class="line"><span class="built_in">NSString</span> *name;<span class="comment">//全局未初始化区（BSS区）</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *myName = <span class="string">@"Jarvis"</span>;<span class="comment">//全局（静态初始化）区</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tmpAge;<span class="comment">//栈</span></span><br><span class="line">    <span class="built_in">NSString</span> *tmpName = <span class="string">@"Jarvis"</span>;<span class="comment">//栈</span></span><br><span class="line">    <span class="built_in">NSString</span> *number = <span class="string">@"123"</span>; <span class="comment">//123在常量区,   number在栈上。</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1</span>];<span class="comment">//分配而来的8字节的区域就在堆中,   array在栈中,   指向堆区的地址</span></span><br><span class="line">    <span class="built_in">NSInteger</span> total = [<span class="keyword">self</span> getTotalNumber:<span class="number">1</span> number2:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)getTotalNumber:(<span class="built_in">NSInteger</span>)number1 number2:(<span class="built_in">NSInteger</span>)number2&#123;</span><br><span class="line">    <span class="keyword">return</span> number1 + number2;<span class="comment">//number1和number2 栈区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="6">堆(heap)和栈(stack)的几个区别:</h3><h4 id="1-申请和回收方式不同"><a href="#1-申请和回收方式不同" class="headerlink" title="1.申请和回收方式不同:"></a>1.申请和回收方式不同:</h4><p><strong>栈区:</strong> 由编译器分配和释放<br><strong>堆区:</strong> 由开发者分配和释放</p><h4 id="2-系统的处理方式不同"><a href="#2-系统的处理方式不同" class="headerlink" title="2.系统的处理方式不同:"></a>2.系统的处理方式不同:</h4><p><strong>栈区:</strong> 栈是一块空间较小,   但是运行速度很快的内存区域。栈上的内存分配遵循后进先出的原则,   通过移动栈的尾指针实现 <code>push</code>(入栈）和 <code>pop</code>(出栈）操作。我们的程序是由一个个方法组成的,   CPU 会负责调度并执行这些方法。当我们的程序执行到某个方法的时候,   需要在栈上为方法需要的内存开辟空间,   此时把栈的尾指针向栈底移动。当方法执行完毕后需要释放掉这些空间,   此时会把栈的尾指针移向栈顶,   这就完成了一次栈上的内存分配。只要栈的剩余空间大于stack 对象申请创建的空间,   操作系统就会为程序提供这段内存空间,   否则将报异常提示栈溢出.  </p><p><strong>堆区:</strong> 系统有一个记录空闲内存地址的链表,   当系统收到程序开辟空间申请时,   会遍历该链表,   寻找第一个空间大于所申请空间的堆结点,   然后将该结点从空闲结点链表中删除,   并将该结点的空间分配给程序,   另外,   对于大多数系统,   会在这块内存空间中的首地址处记录本次分配的大小,   这样才能正确的释放本内存空间。另外,   由于找到的堆结点的大小不一定正好等于申请的大小,   系统会自动的将多余的那部分重新放入空闲链表中.  </p><p>iOS使用了名为 ARC（自动引用计数）的技术。在多线程环境中,   多个线程会共享堆上的内存,   为了确保线程安全,   不得不在堆上进行加锁操作,   但是加锁操作是很耗费性能的,   你在堆上所获的的数据安全性实际上是在牺牲性能的代价下得来的。  </p><p>NSString 的对象就是stack 中的对象,   NSMutableString 的对象就是heap 中的对象。前者创建时分配的内存长度固定且不可修改；后者是分配内存长度是可变的,   可有多个owner,    适用于计数管理内存管理模式。</p><h4 id="3-申请空间大小的不同"><a href="#3-申请空间大小的不同" class="headerlink" title="3.申请空间大小的不同:"></a>3.申请空间大小的不同:</h4><p><strong>栈区:</strong> 栈是从高地址向低地址扩展的数据结构,   是一块连续的内存区域。也就是说栈顶的地址和栈的最大容量是系统预先规定好的,   栈的大小是2M,   如果申请的空间超过栈的剩余空间时,   将提示栈溢出。因此,   能从栈获得的空间较小.  </p><p><strong>堆区:</strong> 堆是从低地址向高地址扩展的数据结构,   是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的,   自然是不连续的,   而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。堆获得的空间比较灵活,   也比较大.</p><h4 id="4-分配方式不同"><a href="#4-分配方式不同" class="headerlink" title="4.分配方式不同:"></a>4.分配方式不同:</h4><p><strong>栈区:</strong> 有2种分配方式：静态分配和动态分配。静态分配是编译器完成的,   比如局部变量的分配。动态分配由<code>alloc</code>函数进行分配,   但是栈的动态分配和堆是不同的,   它的动态分配是由编译器进行释放,   无需我们手工实现。<br><strong>堆区:</strong> 堆都是动态分配的,   没有静态分配的堆。</p><h4 id="5-分配效率不同"><a href="#5-分配效率不同" class="headerlink" title="5.分配效率不同:"></a>5.分配效率不同:</h4><p><strong>栈区:</strong> 栈是操作系统提供的数据结构, 计算机会在底层对栈提供支持, 分配专门的寄存器存放栈的地址, 压栈出栈都有专门的指令执行, 这就决定了栈的效率比较高.</p><p><strong>堆区:</strong> 堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内 存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到 足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><h3 id="7">在Swift中的使用:</h3><p>Swift 中的数据类型分为引用类型（类）和值类型（枚举、结构体）。引用类型存储在 “堆” 上，值类型存储在 “栈” 上。Swift 管理引用类型采用自动引用计数（ARC）的管理方法。值类型是由处理器来管理的，不需要程序员来管理.<br>在 Swift 中，典型的有 <code>struct</code>，<code>enum</code>，以及 <code>tuple</code> 都是值类型。而平时使用的<code>Int</code>，<code>Double</code>，<code>Float</code>，<code>String</code>，<code>Array</code>，<code>Dictionary</code>，<code>Set</code> 其实都是用结构体实现的，也是值类型。Swift 中，值类型的赋值为深拷贝（Deep Copy），值语义（Value Semantics）即新对象和源对象是独立的，当改变新对象的属性，源对象不会受到影响，反之同理。</p><p>在 Swift 中，<code>class</code> 和闭包是引用类型。引用类型的赋值是浅拷贝（Shallow Copy），引用语义（Reference Semantics）即新对象和源对象的变量名不同，但其引用（指向的内存空间）是一样的，因此当使用新对象操作其内部数据时，源对象的内部数据也会受到影响。</p><p>值类型作为参数传入时，函数体内部不能修改其值。引用类型作为参数传入时，函数体内部不能修改其指向的内存地址，但是可以修改其内部的变量值。</p><p>选择值类型而不是引用类型的一个主要原因是能让你的代码变得更加简单。值类型被赋给一个变量或者常量，传给函数做参数时是它的值被拷贝的。这就让值类型在任何时候只有一个享有者，从而降低复杂度。你在任何情况下用一个值类型，都能够假设你的其他代码不会使它改变，这通常在多线程环境中很有用，如果一个线程中使用的数据被另一个线程给意外的修改了，这通常会产生非常严重的Bug，且相当难以调试。</p><p>当你的实例不会对数据进行修改的时候，值类型和引用类型看起来是完全相同的。你也许会想，写一个完全不可变的类，通过使用不可变的存储属性，以及避免暴露修改数据的接口，从而在Swift里实现一个不可变的类。事实上，大多数的Cocoa类，比如NSURL等，都被设计为不可变的类，然而，Swift当前并没有提供任何语言机制去强制申明一个类不可改变（比如子类化就能修改一个类的实现），只有结构体和枚举才是强制不可变的。</p><p>在Swift里，<code>Array</code>、<code>String</code>和<code>Dictionary</code>都是值类型，他们的行为和C语言中的<code>int</code>类似，你不需要额外做任何事情就能防止其他代码在你不知情的情况下修改数据，更重要的是，你能安全地在线程间传递它，而不需要使用同步技术。在提高安全性的前提下，这个模型将帮助你在Swift中写出更多可预知的代码。</p><p>除此之外，Swift和OC还有其他的类型对应，对应关系如下：<br><img src="http://cc.cocimg.com/api/uploads//20180619/1529376567800880.png" alt="OC和Swift对应关系图"><br>但是，对于原来OC中的数据的引用类型，swift中并没有真正的实现一套数据存储逻辑。只是内部保存了对oc对象的引用，使得swift api访问时行为逻辑和值类型一致。</p>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 技术细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 技术细节 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几种常见的排序方法</title>
      <link href="/2018/04/22/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
      <url>/2018/04/22/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>写在前面:以下几种排序算法默认都是升序排列,如果有疏漏或者新增内容后续补充…</p><a id="more"></a><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a><a href="#1">1.冒泡排序</a></h4><h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a><a href="#2">2.选择排序</a></h4><h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a><a href="#3">3.插入排序</a></h4><h4 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a><a href="#4">4.快速排序</a></h4><p><br><br>下面是排序算法的原理和具体的代码实现</p><h4 id="1">1.冒泡排序</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *arr = [NSMutableArray arrayWithArray:@[@<span class="number">3</span>,@<span class="number">34</span>,@<span class="number">44</span>,@<span class="number">12</span>,@<span class="number">15</span>,@<span class="number">1</span>,@<span class="number">35</span>,@<span class="number">22</span>]];</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.count - <span class="number">1</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; arr.count - <span class="built_in">i</span> - <span class="number">1</span>; <span class="built_in">j</span>++) &#123;</span><br><span class="line">            id temp = nil;</span><br><span class="line">            <span class="keyword">if</span> ([arr[<span class="built_in">j</span>] integerValue] &gt; [arr[<span class="built_in">j</span> + <span class="number">1</span>] integerValue]) &#123;</span><br><span class="line">                temp = arr[<span class="built_in">j</span>];</span><br><span class="line">                arr[<span class="built_in">j</span>] = arr[<span class="built_in">j</span> + <span class="number">1</span>];</span><br><span class="line">                arr[<span class="built_in">j</span> + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">NSLog(@<span class="string">"冒泡升序排序: %@"</span>,arr);</span><br></pre></td></tr></table></figure><h4 id="2">2.选择排序</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *arr = [NSMutableArray arrayWithArray:@[@<span class="number">3</span>,@<span class="number">34</span>,@<span class="number">44</span>,@<span class="number">12</span>,@<span class="number">15</span>,@<span class="number">1</span>,@<span class="number">35</span>,@<span class="number">22</span>]];</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.count - <span class="number">1</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="built_in">i</span> + <span class="number">1</span>; <span class="built_in">j</span> &lt; arr.count; <span class="built_in">j</span>++) &#123;</span><br><span class="line">        id temp = nil;</span><br><span class="line">        <span class="keyword">if</span> ([arr[<span class="built_in">j</span>] integerValue] &lt; [arr[<span class="built_in">i</span>] integerValue]) &#123;</span><br><span class="line">            temp = arr[<span class="built_in">i</span>];</span><br><span class="line">            arr[<span class="built_in">i</span>] = arr[<span class="built_in">j</span>];</span><br><span class="line">            arr[<span class="built_in">j</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@<span class="string">"选择升序排序: %@"</span>,arr);</span><br></pre></td></tr></table></figure><h4 id="3">3.插入排序</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *arr = [NSMutableArray  arrayWithArray:@[@<span class="number">3</span>,@<span class="number">34</span>,@<span class="number">44</span>,@<span class="number">12</span>,@<span class="number">15</span>,@<span class="number">1</span>,@<span class="number">35</span>,@<span class="number">22</span>]];</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt; arr.count; <span class="built_in">i</span>++) &#123;</span><br><span class="line">    id num = arr[<span class="built_in">i</span>];</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">j</span> =  <span class="built_in">i</span> - <span class="number">1</span>; <span class="built_in">j</span> &gt;= <span class="number">0</span> &amp;&amp; [num integerValue] &lt; [arr[<span class="built_in">j</span>] integerValue]; <span class="built_in">j</span>--) &#123;</span><br><span class="line">        arr[<span class="built_in">j</span> + <span class="number">1</span>] = arr[<span class="built_in">j</span>];</span><br><span class="line">        arr[<span class="built_in">j</span>] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@<span class="string">"插入升序排序: %@"</span>,arr);</span><br></pre></td></tr></table></figure><h4 id="4">4.快速排序</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)quickSort &#123;</span><br><span class="line">    NSMutableArray *arr = [NSMutableArray <span class="string">arrayWithArray:</span>@[@<span class="number">3</span>,@<span class="number">34</span>,@<span class="number">44</span>,@<span class="number">12</span>,@<span class="number">15</span>,@<span class="number">1</span>,@<span class="number">35</span>,@<span class="number">22</span>]];</span><br><span class="line">    [self <span class="string">quickSortArray:</span>arr <span class="string">withLeftIndex:</span><span class="number">0</span> <span class="string">andRightIndex:</span>arr.count - <span class="number">1</span>];</span><br><span class="line">    NSLog(@<span class="string">"快速升序排序: %@"</span>,arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">quickSortArray:</span>(NSMutableArray *)array <span class="string">withLeftIndex:</span>(NSInteger)leftIndex <span class="string">andRightIndex:</span>(NSInteger)rightIndex &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftIndex &gt;= rightIndex) &#123;</span><br><span class="line">    <span class="comment">//如果数组长度为0或1时返回</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSInteger i = leftIndex;</span><br><span class="line">    NSInteger j = rightIndex;</span><br><span class="line">    <span class="comment">//记录比较基准数</span></span><br><span class="line">    NSInteger key = [array[i] integerValue];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 首先从右边j开始查找比基准数小的值,如果比基准数大，继续查找</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; [array[j] integerValue] &gt;= key) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果比基准数小，则将查找到的小值调换到i的位置</span></span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当在右边查找到一个比基准数小的值时，就从i开始往后找比基准数大的值</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; [array[i] integerValue] &lt;= key) &#123;</span><br><span class="line">        <span class="comment">//如果比基准数小，继续查找</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果比基准数大，则将查找到的大值调换到j的位置</span></span><br><span class="line">        array[j] = array[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将基准数放到正确位置</span></span><br><span class="line">    array[i] = @(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归排序</span></span><br><span class="line">    <span class="comment">//排序基准数左边的</span></span><br><span class="line">    [self <span class="string">quickSortArray:</span>array <span class="string">withLeftIndex:</span>leftIndex <span class="string">andRightIndex:</span>i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//排序基准数右边的</span></span><br><span class="line">    [self <span class="string">quickSortArray:</span>array <span class="string">withLeftIndex:</span>i + <span class="number">1</span> <span class="string">andRightIndex:</span>rightIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>探讨分类和类扩展</title>
      <link href="/2017/08/12/%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/"/>
      <url>/2017/08/12/%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<p>  在最初学习<code>category</code>和<code>extension</code>的时候感觉很是头大，什么是分类，什么是类扩展，他们分别用在什么场合，各有哪些特点？后来随着自己的深入了解，发现这真的是很出色的两种扩展。希望把自己的经验写出来，让更多人能够理解分类和类扩展，并实际运用他们。</p><a id="more"></a><p>分类运用场景举例：想要收集每个页面的启动时间。</p><h4 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h4><p>问题:<br>项目中已经有上百个页面了，如果一个一个的加，浪费时间不说，以后增加了新页面，还需要添加方法。</p><p>解决方法:<br>我们可以发现页面都继承了<code>UIViewController</code>，想要在每个页面都执行的代码，可以写在这些页面的父类中。我们可以把代码写在<code>UIViewController</code>中。</p><h4 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h4><p>问题:<br><code>UIViewController</code>是官方类，我们只能调用期接口，并不能修改他的实现。</p><p>解决方法:<br>使用分类（category）。</p><h4 id="关于分类的一些重点"><a href="#关于分类的一些重点" class="headerlink" title="关于分类的一些重点"></a>关于分类的一些重点</h4><h5 id="分类category的作用"><a href="#分类category的作用" class="headerlink" title="分类category的作用"></a>分类<code>category</code>的作用</h5><ul><li>作用：可以在不修改原来类的基础上，为一个类扩展方法。</li><li>最主要的用法：给系统自带的类扩展方法。</li></ul><h5 id="分类category中能写点啥-？"><a href="#分类category中能写点啥-？" class="headerlink" title="分类category中能写点啥 ？"></a>分类<code>category</code>中能写点啥 ？</h5><ul><li>分类中只能添加“方法”，不能增加成员变量。</li><li>分类中可以访问原来类中的成员变量，但是只能访问<code>@protect</code>和<code>@public</code>形式的变量。如果想要访问本类中的私有变量，分类和子类一样，只能通过方法来访问。</li><li>如果一定要在分类中添加成员变量，可以通过<code>getter</code>，<code>setter</code>手段进行添加，详细以后再写</li></ul><h5 id="分类的创建方法"><a href="#分类的创建方法" class="headerlink" title="分类的创建方法"></a>分类的创建方法</h5><p>分类的创建方法如下图:<br><img src="https://ws1.sinaimg.cn/large/006tKfTcly1ft6xmneeclj30ou05sjrd.jpg" alt="分类的创建方法"></p><h5 id="分类的书写方法"><a href="#分类的书写方法" class="headerlink" title="分类的书写方法"></a>分类的书写方法</h5><p>  假设我们有一个类，名叫<code>Person</code>，意义是人类。在<code>person</code>类中我们有一个方法，<code>-(void)eat;</code>意义是吃，因为每个人类都会吃。<br>人类有非常多的共同属性,也有非常多的不同属性。有的人会说英语有的人就不会,所以我们给会说英语的人添加一个说英语的分类<code>speakEnglish</code>因为是<code>Person</code>类的分类，你会看到生成的名字叫做<code>Person+ speakEnglish</code>。下面让我们来试着添加一下。</p><ul><li>分类的使用过程：声明分类-&gt;实现分类-&gt;使用分类</li><li>在项目中添加类，选择Objective-C File，填写分类的类名 -&gt; 选择文件类型是分类 -&gt; 选择类</li><li>在<code>类名 + 分类名称.h</code>中声明方法</li><li>在<code>类名 + 分类名称.m</code>中实现方法</li></ul><!--第四: 回到最开始收集页面启动时间的问题，本类是系统的类，这里是UIViewController，我们可以使用分类扩展他的方法，也可以重写他的方法，可以我需要在调用的地方加头文件，所有子类都写头文件和直接在子类写方法没有什么区别，怎么样可以使得不写头文件，子类就能调用我们写的代码呢？回答：我们可以进行方法交换（这样可以不必在调用的地方增加头文件），从而使得在实现的时候调用重写的方法。具体实现以后会写，TODO--><h5 id="分类的执行优先级"><a href="#分类的执行优先级" class="headerlink" title="分类的执行优先级"></a>分类的执行优先级</h5><ul><li>在本类和分类有相同的方法时，优先调用分类的方法再调用本类的方法。</li><li>如果有两个分类，他们都实现了相同的方法，如何判断谁先执行？分类执行顺序可以通过<code>targets,Build Phases,Complie Source</code>进行调节，注意执行顺序是从上到下的。（只有两个相同方法名的分类）</li></ul><h5 id="分类category和类扩展extension的关系"><a href="#分类category和类扩展extension的关系" class="headerlink" title="分类category和类扩展extension的关系"></a>分类<code>category</code>和类扩展<code>extension</code>的关系</h5><ul><li>类扩展<code>extension</code>是<code>category</code>的一个特例，有时候也被称为匿名分类。他的作用是为一个类添加一些私有的成员变量和方法。</li><li>类扩展能写点啥？和分类不同，类扩展即可以声明成员变量又可以声明方法。</li><li>类扩展听上去很复杂，但其实我们很早就认识他了。你记得继承自<code>UIViewController</code>的<code>ViewController</code>和继承自<code>NSObject</code>的类有什么不同么？<br>继承自<code>UIViewController</code>的<code>ViewController</code>类,对比看一下继承自<code>NSObject</code>的类我们会发现没有下面的代码块<br>  <code>@interface ViewController()</code><font color="#006600">&emsp;&emsp;//这就是类扩展的写法</font><br> <code>@end</code></li><li>类扩展可以定义在<code>.m</code>文件中，这种扩展方式中定义的变量都是私有的，也可以定义在<code>.h</code>文件中，这样定义的代码就是共有的，类扩展在<code>.m</code>文件中声明私有方法是非常好的方式。</li><li>类扩展中添加的新方法，一定要实现,<code>category</code>中没有这种限制。</li></ul>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 技术细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 技术细节 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS中 typedef 和 define 理解</title>
      <link href="/2017/06/07/typedef%20%E5%92%8C%20define%20%E7%9A%84%E5%BE%AE%E8%A7%A3%E9%87%8A/"/>
      <url>/2017/06/07/typedef%20%E5%92%8C%20define%20%E7%9A%84%E5%BE%AE%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[<p>写在前面,学习iOS开发的过程中会遇到一些很细节的问题,但是这些问题对于开发和学习又很重要所以就把这些东西记录下来方便回顾和分享给大家,本章主要讨论 <code>define</code> ,<code>typedef</code>的区别.</p><a id="more"></a><h4 id="1-typedef-类型定义"><a href="#1-typedef-类型定义" class="headerlink" title="1. typedef 类型定义"></a>1. <code>typedef</code> 类型定义</h4><p>作用: 类型替换: 就是把复杂类型改一个简单的名字.</p><p>示例:</p><p><font color="#006600"> // 给float取别名为floatX</font><br><code>typedef float floatX;</code> </p><p><font color="#006600"> // 给block取别名passBlock</font><br><code>typedef void(^passBlock) (int a,int b);</code></p><p><font color="#006600"> // 给PersonObject结构体取别名为person。使用方法: person p = {“Jarvis”};</font><br><code>typedef struct PersonObject{    NSString *name;}person;</code></p><h4 id="2-define-宏定义"><a href="#2-define-宏定义" class="headerlink" title="2. define 宏定义"></a>2. <code>define</code> 宏定义</h4><p>作用: 文本替换: 把出现的文本替换为定义的文本.</p><p>示例:</p><p><font color="#006600"> // kSayHello 替换后面的文本</font><br><code>#define kSayHello @&quot;Hello World !&quot;</code></p><p><font color="#006600"> // kSayHelloTwo 替换 kSayHello</font><br><code>#define kSayHelloTwo kSayHello</code></p><h4 id="3-define和typedef的使用注意事项"><a href="#3-define和typedef的使用注意事项" class="headerlink" title="3. define和typedef的使用注意事项"></a>3. <code>define</code>和<code>typedef</code>的使用注意事项</h4><ul><li><p><code>define</code> 是文本替换，是预编译指令，本身不参与编译，除非希望替换的文本中有<code>;</code>否则不用加<code>;</code><br><code>typedef</code> 是类型替换，语句的一种，结尾必须有<code>;</code></p></li><li><p><code>define</code> 在方法/函数中则作用域从写的地方开始有效，直至使用<code>#undef</code>（不写此指令则后面一直有效）。<code>typedef</code> 写在方法/函数中则作用域 只在此方法/函数中有效。</p></li><li><p>若使用<code>typedef char * MyString;</code>则 <code>MyString s1,s2</code> 等价于  <code>char *s1</code>; <code>char *s2</code></p></li><li><p>若使用 <code>#define MyString char *</code> 则 <code>MyString s1,s2</code> 等价于<code>char *s1,s2</code> 即 <code>char *s1</code>; <code>char s2</code></p></li><li><p>再次说明了<code>typedef</code>是类型替换，直接参与编译，而<code>define</code>只是简单的文本替换.</p></li></ul>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 技术细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 技术细节 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象的六大原则</title>
      <link href="/2017/03/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2017/03/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<p>思想是编程的灵魂,面向对象的编程思想,各种设计模式掌握的好才能写出稳健,易用,扩展性好,测试性好的代码.<br><a id="more"></a></p><h5 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1.单一职责原则 (SRP)"></a>1.单一职责原则 (SRP)</h5><blockquote><p><strong>定义:</strong>      对于一个类来说,引起它变化的原因应该只有一个</p><p><strong>解释:</strong>  一个类是一组相关性很高的函数,一个类尽量只实现一个功能</p></blockquote><h5 id="2-开闭原则-OCP"><a href="#2-开闭原则-OCP" class="headerlink" title="2.开闭原则 (OCP)"></a>2.开闭原则 (OCP)</h5><blockquote><p><strong>定义:</strong>  程序中的对象应该是扩展开放,对修改封闭.这个原则同样也适合于控件的封装.</p><p><strong>解释:</strong>  当一个类实现了一个功能,想要增加新的功能或者改变这个功能的时候不是去修改这个类而是通过扩展来实现.实现该类的接口方法来实现扩展,或者使用集成或分类来实现.</p></blockquote><h5 id="3-里氏替换原则-LSP"><a href="#3-里氏替换原则-LSP" class="headerlink" title="3.里氏替换原则 (LSP)"></a>3.里氏替换原则 (LSP)</h5><blockquote><p><strong>定义:</strong>  使用基类的地方必须能使用其子类对象</p><p><strong>解释:</strong>  只要父类能出现的地方子类就可以使用,替换为子类也不会产生错误.开闭原则可以通过里氏替换原则来实现.</p></blockquote><h5 id="4-依赖倒置原则-DIP"><a href="#4-依赖倒置原则-DIP" class="headerlink" title="4.依赖倒置原则 (DIP)"></a>4.依赖倒置原则 (DIP)</h5><blockquote><p><strong>定义:</strong>  模块间依赖抽象化</p><p><strong>解释:</strong>  模块间通过抽象依赖,实体类之间不直接发生依赖关系,其依赖关系是通过接口或者抽象类产生.</p></blockquote><h5 id="5-接口隔离原则-ISP"><a href="#5-接口隔离原则-ISP" class="headerlink" title="5.接口隔离原则 (ISP)"></a>5.接口隔离原则 (ISP)</h5><blockquote><p><strong>定义:</strong>  类或者模块不应该依赖它不需要的接口</p><p><strong>解释:</strong>  接口隔离可以使系统解耦合,更容易更改或者重构,对其他模块造成的影响最小.</p></blockquote><h5 id="6-迪米特原则-LOD"><a href="#6-迪米特原则-LOD" class="headerlink" title="6.迪米特原则 (LOD)"></a>6.迪米特原则 (LOD)</h5><blockquote><p><strong>定义:</strong>  一个对象对其他对象了解的越少越好</p><p><strong>解释:</strong>  一个类应该对引用的类知道的越少越好,类的内部实现与调用者没有关系</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 编程思想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发牛人博客</title>
      <link href="/2016/02/08/iOS%E5%BC%80%E5%8F%91%E7%89%9B%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2016/02/08/iOS%E5%BC%80%E5%8F%91%E7%89%9B%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>学习iOS开发的过程总是想看看牛人们的学习和工作方式,收藏一些牛人的博客供学习!</p><a id="more"></a><ul><li>王巍的博客：<a href="http://onevcat.com" target="_blank" rel="noopener">http://onevcat.com</a></li><li>池建强的博客：<a href="http://macshuo.com" target="_blank" rel="noopener">http://macshuo.com</a></li><li>唐巧的博客：<a href="http://blog.devtang.com" target="_blank" rel="noopener">http://blog.devtang.com</a></li><li>许小帅的博客：<a href="http://imallen.com" target="_blank" rel="noopener">http://imallen.com</a></li><li>蓝晨钰的博客：<a href="http://gracelancy.com" target="_blank" rel="noopener">http://gracelancy.com</a></li><li>萧宸宇的博客：<a href="http://iiiyu.com" target="_blank" rel="noopener">http://iiiyu.com</a></li><li>陶丰平的博客：<a href="http://www.taofengping.com" target="_blank" rel="noopener">http://www.taofengping.com</a></li><li>乔学士的博客：<a href="http://joeyio.com" target="_blank" rel="noopener">http://joeyio.com</a></li><li>破船的博客: <a href="http://beyondvincent.com" target="_blank" rel="noopener">http://beyondvincent.com</a></li><li>陈咏聪的博客：<a href="http://vinqon.com" target="_blank" rel="noopener">http://vinqon.com</a></li><li>骆仕恺的博客: <a href="http://luosky.com" target="_blank" rel="noopener">http://luosky.com</a></li><li>耿健桓的博客：<a href="http://dlog.dismory.com" target="_blank" rel="noopener">http://dlog.dismory.com</a></li><li>李择一的博客：<a href="http://cnblogs.com/biosli" target="_blank" rel="noopener">http://cnblogs.com/biosli</a></li><li>王轲的博客：<a href="http://www.iwangke.me" target="_blank" rel="noopener">http://www.iwangke.me</a></li><li>杨宇建的博客：<a href="http://www.cnblogs.com/easonoutlook" target="_blank" rel="noopener">http://www.cnblogs.com/easonoutlook</a></li><li>连栩的博客： <a href="http://lianxu.me" target="_blank" rel="noopener">http://lianxu.me</a></li><li>高嘉峻的博客：<a href="http://jiajun.org" target="_blank" rel="noopener">http://jiajun.org</a></li><li>webfrogs的博客：<a href="http://webfrogs.me" target="_blank" rel="noopener">http://webfrogs.me</a></li><li>sunny的博客：<a href="http://blog.sunnyxx.com" target="_blank" rel="noopener">http://blog.sunnyxx.com</a></li><li>景总的博客：<a href="http://blog.csdn.net/justinjing0612" target="_blank" rel="noopener">http://blog.csdn.net/justinjing0612</a></li><li>谭灏的博客：<a href="http://tanhao.me" target="_blank" rel="noopener">http://tanhao.me</a></li><li>田伟宇的博客：<a href="http://casatwy.com" target="_blank" rel="noopener">http://casatwy.com</a></li><li>念茜的博客: <a href="http://nianxi.net" target="_blank" rel="noopener">http://nianxi.net</a></li></ul><p>目前收录这么多牛人博客,后序再慢慢添加! 如果大家有好的博客,欢迎推荐!!</p>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 技术提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 技术提升 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>简介</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>参加过多个产品的设计,交互,技术定型,开发,发布等完成的开发流程.具有快速学习的能力和沟通能力，能够快速融入团队,喜欢钻研新技术，更把新技术完美运用到项目中为乐趣,对工作和生活有很强的责任心,认真对待做的每一件事情.</p><h4 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h4><p> 邮箱: zjm100163@163.com</p>]]></content>
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
