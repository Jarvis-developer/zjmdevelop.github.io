<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>App的启动优化和监控</title>
      <link href="/2018/08/08/App%E7%9A%84%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
      <url>/2018/08/08/App%E7%9A%84%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>今天咱们聊一聊App启动的速度和优化的问题.在提供的功能和服务相似的情况下，一款 App 的启动速度，不单单是用户体验的事情，往往还决定了它能否获取更多的用户。这就好像陌生人第一次碰面，第一感觉往往决定了他们接下来是否会继续交往。</p><a id="more"></a><p>启动速度的优化必然就是 App 开发过程中不可或缺的一个环节。接下来，我们一起分析下 App 在启动时都做了哪些事儿。</p><h4 id="App启动时动都做了哪些事"><a href="#App启动时动都做了哪些事" class="headerlink" title="App启动时动都做了哪些事?"></a>App启动时动都做了哪些事?</h4><p>一般情况下，App 的启动分为冷启动和热启动。</p><ul><li><p>冷启动是指，App 点击启动前，它的进程不在系统里，需要系统新创建一个进程分配给它启动的情况.这也是一个完整的启动过程.</p></li><li><p>热启动是指, App冷启动后用户将App退到后台,在 App 的进程还在系统里的情况下, 用户重新进入到 App 的过程,这个过程 App 做的事情很少.</p></li></ul><p>所以，今天我们就只讨论 App 冷启动的优化。</p><p>用户能感知到的启动慢，其实都发生在主线程上。而主线程慢的原因有很多，比如在主线程上执行了大文件读写操作、在渲染周期中执行了大量计算等。但是，有时你会发现即使你把首屏显示之前的这些主线程的耗时问题都解决了，还是比竞品启动得慢。</p><p>那么，究竟如何才能把启动时的所有耗时都找出来呢？解决这个问题，你首先需要弄清楚 App 在启动时都干了哪些事儿。</p><p>一般而言，App 的启动时间，指的是从用户点击 App 开始，到用户看到第一个界面之间的时间。总结来说，App 的启动主要包括三个阶段：</p><h4 id="1-main-函数执行前"><a href="#1-main-函数执行前" class="headerlink" title="1. main() 函数执行前"></a><a href="#1">1. main() 函数执行前</a></h4><h4 id="2-main-函数执行后"><a href="#2-main-函数执行后" class="headerlink" title="2. main() 函数执行后"></a><a href="#2">2. main() 函数执行后</a></h4><h4 id="3-首屏渲染完成前"><a href="#3-首屏渲染完成前" class="headerlink" title="3. 首屏渲染完成前"></a><a href="#3">3. 首屏渲染完成前</a></h4><h4 id="1">1. main() 函数执行前</h4><p>在 main() 函数执行前，系统主要会做下面几件事情：</p><ul><li>App可执行文件的加载,可执行文件也就是 App 的 <code>.o</code> 文件的集合.</li><li>动态链接库的加载,进行 release 指针的调整和 bind 号绑定.</li><li>objc 运行时的初始化,包括了 objc 相关类的注册, category 的注册, selector 唯<br>一性检查.</li><li>初始化, 包括执行 +load() 方法, attribute 修饰的函数的调用, 全局静态变量的调用.</li></ul><p>相应地，这个阶段对于启动速度优化来说，可以做的事情包括：</p><ul><li>减少动态库的加载, 每个库都会有依赖关系, Apple 也建议我们尽量减少动态库的数量, 并且在动态库较多的时候尽量将动态库合并. Apple 支持最多6个非系统动态库合并成一个.</li><li>减少启动后不会马上用到的类和方法的加载.</li><li>+load() 里的内容可以放到首屏渲染完成后再执行或者用 +initialize() 方法替换掉. 在 +load() 方法里面进行运行时方法的替换会带来 4ms 的时间消耗. 积少成多会对 App 的启动影响比较大.</li><li>控制全局变量的数量.</li></ul><h4 id="2">2. main() 函数执行后</h4><p>main() 函数执行后的阶段，指的是从 main() 函数执行开始，到 appDelegate 的didFinishLaunchingWithOptions 方法里首屏渲染相关方法执行完成。<br>首页的业务代码都是要在这个阶段，也就是首屏渲染前执行的，主要包括了：</p><ul><li>首屏初始化所需配置文件的读取.</li><li>首屏渲染所需数据的读取.</li><li>首屏渲染所需的计算.</li></ul><p>很多时候，开发者会把各种初始化工作都放到这个阶段执行，导致渲染完成滞后。更加优化的开发方式，应该是从功能上梳理出哪些是首屏渲染必要的初始化功能，哪些是 App 启动必要的初始化功能，而哪些是只需要在对应功能开始使用时才需要初始化的。梳理完之后，将这些初始化功能分别放到合适的阶段进行。</p><h4 id="3">3. 首屏渲染完成后</h4><p>首屏渲染后的这个阶段，主要完成的是，非首屏其他业务服务模块的初始化、监听的注册、配置文件的读取等。从函数上来看，这个阶段指的就是截止到 <code>didFinishLaunchingWithOptions</code> 方法作用域内执行首屏渲染之后的所有方法执行完成。简单说的话，这个阶段就是从渲染完成时开始，到 <code>didFinishLaunchingWithOptions</code> 方法作用域结束时结束。<br>这个阶段用户已经能够看到 App 的首页信息了，所以优化的优先级排在最后。但是，那些会卡住主线程的方法还是需要最优先处理的，不然还是会影响到用户后面的交互操作。</p><p>明白了 App 启动阶段需要完成的工作后，我们就可以有的放矢地进行启动速度的优化了。这些优化包括了两个方面:</p><h4 id="1-功能级别的优化"><a href="#1-功能级别的优化" class="headerlink" title="1. 功能级别的优化"></a><a href="#11">1. 功能级别的优化</a></h4><h4 id="2-方法级别的优化"><a href="#2-方法级别的优化" class="headerlink" title="2. 方法级别的优化"></a><a href="#12">2. 方法级别的优化</a></h4><h4 id="11"> 1. 功能级别的优化</h4><p>在 App 项目开发初期，开发人员不多、代码量也没那么大时，这种情况比较少见。但到了后期 ，App 业务规模扩大，团队人员水平参差不齐，各种代码问题就会爆发出来，终归需要来次全面治理。而全面治理过程中的手段、方法和碰到的问题，对于后面的规范制定以及启动速度监控都有着重要的意义。那么，我们要怎样从功能级别来进行全面的启动优化治理呢？</p><p>功能级别的启动优化，就是要从 main() 函数执行后这个阶段下手。</p><p>优化的思路是： main() 函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做。</p><h4 id="12"> 2. 方法级别的优化</h4><p>经过功能级别的启动优化，也就是将非首屏业务所需的功能滞后以后，从用户点击 App 到看到首屏的时间将会有很大程度的缩短，也就达到了优化 App 启动速度的目的。</p><p>在这之后，我们需要进一步做的，是检查首屏渲染完成前主线程上有哪些耗时方法，将没必要的耗时方法滞后或者异步执行。通常情况下，耗时较长的方法主要发生在计算大量数据的情况下，具体的表现就是加载、编辑、存储图片和文件等资源。</p><p>那么，你觉得是不是只需要优化对资源的操作就可以了呢？<br>当然不是。就像 +load() 方法，一个耗时 4 毫秒，100 个就是 400 毫秒，这种耗时用户也是能明显感知到的。比如 ReactiveCocoa 框架，每创建一个信号都有 6 毫秒的耗时。这样，稍不注意各种信号的创建就都被放在了首屏渲染完成前，进而导致 App 的启动速度大幅变慢。</p><p>类似这样单个方法耗时不多，但是由于堆积导致 App 启动速度大幅变慢的方法数不胜数。所以，你需要一个能够对启动方法耗时进行全面、精确检查的手段。</p><p>那么问题来了，有哪些监控手段？这些监控手段各有什么优缺点？你又该如何选择呢？</p><p>目前来看，对 App 启动速度的监控，主要有两种手段。</p><p>第一种方法是，定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时。Xcode 工具套件里自带的 Time Profiler ，采用的就是这种方式。这种方式的优点是，开发类似工具成本不高，能够快速开发后集成到你的 App 中，以便在真实环境中进行检查。<br>说到定时抓取，就会涉及到定时间隔的长短问题。</p><p>这个定时间隔如果小于所有方法执行的时间（比如 0.002 秒），那么基本就能监控到所有方法。但这样做的话，整体的耗时时间就不够准确。一般将这个定时间隔设置为 0.01 秒。这样设置，对整体耗时的影响小，不过很多方法耗时就不精确了。但因为整体耗时的数据更加重要些，单个方法耗时精度不高也是可以接受的，所以这个设置也是没问题的。</p><p>总结来说，定时抓取主线程调用栈的方式虽然精准度不够高，但也是够用的。</p><p>第二种方法是，对 <code>objc_msgSend</code> 方法进行 hook 来掌握所有方法的执行耗时。</p><p>hook 方法的意思是，在原方法开始执行时换成执行其他你指定的方法，或者在原有方法执行前后执行你指定的方法，来达到掌握和改变指定方法的目的。</p><p><code>hook objc_msgSend</code> 这种方式的优点是非常精确，而缺点是只能针对 Objective-C 的方法。当然，对于 c 方法和 block 也不是没有办法，你可以使用 libffi 的 ffi_call 来达成 hook，但缺点就是编写维护相关工具门槛高。</p><p>综上，如果对于检查结果精准度要求高的话，我比较推荐你使用 <code>hook objc_msgSend</code> 方式来检查启动方法的执行耗时。<br>使用 <code>hook objc_msgSend</code> 方式来检查启动方法的执行耗时时.</p><p><code>objc_msgSend</code> 方法执行的逻辑是：先获取对象对应类的信息，再获取方法的缓存，根据方法的 selector 查找函数指针，经过异常错误处理后，最后跳到对应函数的实现。</p><p>具体的hook 工具等我详细学习之后再补充….</p>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> App优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> App的启动优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设备唯一标识符汇总</title>
      <link href="/2018/06/18/%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6%E6%B1%87%E6%80%BB/"/>
      <url>/2018/06/18/%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p>看到大家有时候用到设备的唯一标识符总是会弄混或者记不清楚.在这里做一下记录.设备的唯一标识符具体可以分为如下几种：</p><h4 id="1、UDID"><a href="#1、UDID" class="headerlink" title="1、UDID"></a><a href="#1">1、UDID</a></h4><h4 id="2、MAC"><a href="#2、MAC" class="headerlink" title="2、MAC"></a><a href="#2">2、MAC</a></h4><h4 id="3、IDFA"><a href="#3、IDFA" class="headerlink" title="3、IDFA"></a><a href="#3">3、IDFA</a></h4><h4 id="4、IDFV"><a href="#4、IDFV" class="headerlink" title="4、IDFV"></a><a href="#4">4、IDFV</a></h4><h4 id="5、UUID"><a href="#5、UUID" class="headerlink" title="5、UUID"></a><a href="#5">5、UUID</a></h4><h4 id="6、常用标识方法"><a href="#6、常用标识方法" class="headerlink" title="6、常用标识方法"></a><a href="#6">6、常用标识方法</a></h4><a id="more"></a><p>下面我们来具体分析下每种标识获取的可行性和使用的利弊：</p><h4 id="1">1、UDID（Unique Device Identifier Description）</h4><p>UDID 是由字母和数字组成的40个字符串的序号，用来区别每一个唯一的iOS设备，这些编码看起来是随机的，但实际上是跟硬件设备特点相关联的。我们平时用开发者账号在设备上安装测试应用时，往开发者账号上添加的就是设备的UDID。<code>iOS 2.0</code> 版本以后，苹果提供了一个获取设备唯一标识符的方法<br><code>NSString *UDID = [[UIDevice currentDevice] uniqueIdentifier];</code><br>通过该方法我们可以获取设备的序列号，这个也是目前为止唯一可以确认的唯一的标示符。由于UDID是跟设备唯一对应的，许多开发者试图通过UDID获取到用户的真实姓名、密码、地址等隐私数据。为了避免引起麻烦，苹果在<code>iOS 5.0</code> 的时候，废除了UDID的代码获取权限。现在应用试图获取UDID已被禁止且不允许上架。</p><h4 id="2">2、MAC（Medium/Media Access Control）</h4><p>Mac地址是用来表示互联网上每一个站点的标识符，采用十六进制数表示，共六个字节（48位）。MAC地址在网络上用来区分设备的唯一性，接入网络的设备都有一个MAC地址，他们肯定都是不同的，是唯一的。一部iPhone上可能有多个MAC地址，包括WIFI的、SIM的等，但是iTouch和iPad上就有一个WIFI的，因此只需获取WIFI的MAC地址就好了，也就是en0的地址。形象的说，MAC地址就如同我们身份证上的身份证号码，具有全球唯一性。这样就可以非常好的标识设备唯一性。UDID被禁用后，因为每个设备上的Mac地址是唯一的，所以大部分的app开发者都开始使用Mac地址来代替UDID.但MAC地址跟UDID一样，存在隐私问题，所以在 <code>iOS 7.0</code> 之后，Mac地址再次遭到苹果的无情封杀.</p><h4 id="3">3、IDFA （Identifier For Advertising）</h4><p>这是 <code>iOS 6.0</code>之后提供的一个新方法，在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的。获取 IDFA 的方法如下：</p><p><code>NSString *idfa = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];</code></p><p>但是IDFA并不是唯一不变的，如果用户完全重置系统（设置程序 -&gt; 通用 -&gt; 还原 -&gt; 还原位置与隐私） ，这个广告标示符会重新生成。另外如果用户明确的还原广告（设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 还原广告标示符） ，那么广告标示符也会重新生成。在<code>iOS 10</code>以后如果用户打开限制广告跟踪（设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 限制广告跟踪），则获取到的IDFA为一个固定值<code>00000000-0000-0000-0000-000000000000</code>。因此，通过IDFA也无法唯一标识一个设备。</p><h4 id="4">4、IDFV（Identifier For Vendor）</h4><p>IDFV是给Vendor标识用户用的，每个设备在所属同一个Vendor的应用里，都有相同的值。其中的Vendor是指应用提供商，准确的说，是通过BundleID的反转的前两部分进行匹配，如果相同就是同一个Vendor，例如对于<code>com.abc.app1</code>, <code>com.abc.app2</code> 这两个BundleID来说，就属于同一个Vendor，共享同一个IDFV的值。当然，对于同一个设备不同Vendor的话，获取到的值是不同的。和IDFA不同的是，IDFV的值是一定能取到的。它是<code>iOS 6</code>中新增的，获取方法如下：</p><p><code>NSString *strIDFV = [[[UIDevice currentDevice] identifierForVendor] UUIDString];</code></p><p>但是使用IDFV也会存在一些问题。如果用户将属于此Vendor的所有App卸载，则IDFV的值会被重置，即再重装此Vendor的App，IDFV的值也会和之前的不同.</p><h4 id="5">5、UUID（Universally Unique Identifier）</h4><p>UUID是<code>Universally Unique Identifier</code>的缩写，中文意思是通用唯一识别码。它是苹果提供的一个获取大随机数的方法，据说UUID随机数算法得到的数重复概率为170亿分之一。这样，每个人都可以建立不与其它人冲突的 UUID。</p><ol><li>CFUUID</li></ol><p>从iOS 2.0开始，CFUUID就已经出现了。它是CoreFoundation包的一部分，因此API属于C语言风格。获取方法参考如下代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFUUIDRef cfuuid = CFUUIDCreate(<span class="name">kCFAllocatorDefault</span>)<span class="comment">;</span></span><br><span class="line">NSString *cfuuidString = (<span class="name">NSString*</span>)CFBridgingRelease(<span class="name">CFUUIDCreateString</span>(<span class="name">kCFAllocatorDefault</span>, cfuuid))<span class="comment">;</span></span><br></pre></td></tr></table></figure><ol><li>NSUUID</li></ol><p>NSUUID在<code>iOS 6.0</code>中才出现，这跟CFUUID几乎完全一样，只不过它是Objective-C接口。通过下面的代码可以获得一个UUID字符串：</p><p><code>NSString *uuid = [[NSUUID UUID] UUIDString];</code></p><p>苹果公司建议使用UUID为应用生成唯一标识字符串。但是获得的UUID值系统没有存储, 而且每次调用得到UUID，系统都会返回一个新的唯一标示符。如果你希望存储这个标示符，那么需要自己将其存储到NSUserDefaults, Keychain, Pasteboard或其它地方。</p><h4 id="6">6、常用标识方法 (UUID + Keychain)</h4><p>原来苹果是提供获取UDID的API的<code>[UIDevice uniqueIdentifier]</code>,因为被人滥用,所以变成了私有API,我们都知道私有API是不能上架Appstore的.再后来随着苹果对程序内获取UDID封杀的越来越严格,私有API已经获取不到存取到系统或者硬件中的UDID了,Mac地址等信息.继而出现了使用钥匙串配合UUID,推送Token等方法变相实现</p><p>iOS 提供了生成UUID的API,使用方法,每次调用get_UUID返回的UUID字符串都是不同的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)get_UUID</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>([[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] floatValue] &gt; <span class="number">6.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span>  [[<span class="built_in">NSUUID</span> UUID] UUIDString];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CFUUIDRef</span> uuidRef = <span class="built_in">CFUUIDCreate</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">CFStringRef</span> uuid = <span class="built_in">CFUUIDCreateString</span>(<span class="literal">NULL</span>, uuidRef);</span><br><span class="line">        <span class="built_in">CFRelease</span>(uuidRef);</span><br><span class="line">        <span class="keyword">return</span> (__bridge_transfer <span class="built_in">NSString</span> *)uuid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了存储唯一标识符我们可以用以下几种方式:</p><ul><li>NSUserdefault</li></ul><p>数据存储后可以关闭app后依然存在,只有卸载App 或者手动删除, 数据才会消失.由于NSUserdefault和APP安装到卸载的生命周期相同,所以重新卸载安装获取UUID,会是新生成的随机UUID.调用<code>get_uui</code>d生成一个UUID  <code>24f4b977-4c4a-4e67-84c6-01a473a33fc7</code>  </p><p>存入</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *<span class="keyword">user</span>Defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">[<span class="keyword">user</span>Defaults <span class="built_in">set</span>Object:@<span class="string">"24f4b977-4c4a-4e67-84c6-01a473a33fc7"</span> <span class="keyword">for</span>Key:@<span class="string">"KEY_DEVICE_UUID"</span>];</span><br><span class="line">[<span class="keyword">user</span>Defaults synchronize];</span><br></pre></td></tr></table></figure><p>读取</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line"><span class="built_in">NSString</span> *username = [userDefaults objectForKey:<span class="string">@"KEY_DEVICE_UUID"</span>];</span><br></pre></td></tr></table></figure><ul><li>Keychain</li></ul><p>数据可以删除app后依然存在,属于只能此app读写(开发商多个app可以使用keychain group共享).钥匙串由操作系统保护并且存储后的数据是比较安全的,常用来存储一些密码,私钥.当系统被重置的时候keychain会被清空.</p>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 技术细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 唯一标识符 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>离屏渲染</title>
      <link href="/2018/05/29/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"/>
      <url>/2018/05/29/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/</url>
      <content type="html"><![CDATA[<p>离屏渲染往往会带来界面卡顿的问题，这里将会讨论 当前屏幕渲染、离屏渲染 以及 CPU 渲染.</p><a id="more"></a><p>在 OpenGL 中，GPU 屏幕渲染有以下两种方式：</p><p><strong>∙ On-Screen Rendering</strong><br>即当前屏幕渲染，在用于显示的屏幕缓冲区中进行，不需要额外创建新的缓存，也不需要开启新的上下文，所以性能较好，但是受到缓存大小限制等因素，一些复杂的操作无法完成。</p><p><strong>∙ Off-Screen Rendering</strong><br>即离屏渲染，指的是在 GPU 的当前屏幕缓冲区外开辟新的缓冲区进行操作。</p><p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在如下两个方面：<br><strong>∙ 创建新的缓冲区</strong></p><p><strong>∙ 上下文切换。离屏渲染的整个过程，需要多次切换上下文环境：先从当前屏幕切换到离屏，等待离屏渲染结束后，将离屏缓冲区的渲染结果显示到到屏幕上，这又需要将上下文环境从离屏切换到当前屏幕。</strong></p><p>当设置了以下属性时，会触发离屏渲染：</p><ol><li>shouldRasterize（光栅化）</li><li>masks（遮罩）</li><li>shadows（阴影）</li><li>edge antialiasing（抗锯齿）</li><li>group opacity（不透明）</li></ol><p>为了避免卡顿问题，应当尽可能使用当前屏幕渲染，可以不使用离屏渲染则尽量不用，应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术。必须离屏渲染时，相对简单的视图应该使用 CPU 渲染，相对复杂的视图则使用一般的离屏渲染。</p><p>如下是 CPU 渲染和离屏渲染的区别：</p><p>由于GPU的浮点运算能力比CPU强，CPU渲染的效率可能不如离屏渲染。但如果仅仅是实现一个简单的效果，直接使用 CPU 渲染的效率又可能比离屏渲染好，毕竟普通的离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。对一些简单的绘制过程来说，这个过程有可能用CoreGraphics，全部用CPU来完成反而会比GPU做得更好。一个常见的 CPU 渲染的例子是：重写 drawRect 方法，并且使用任何 Core Graphics 的技术进行了绘制操作，就涉及到了 CPU 渲染。整个渲染过程由 CPU 在 App 内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。总之，具体使用 CPU 渲染还是使用 GPU 离屏渲染更多的时候需要进行性能上的具体比较才可以。</p><p>一个常见的性能优化的例子就是如何给 UIView/UIImageView 加圆角。</p><p>如下是三种加圆角的方式：</p><ol><li>设置 cornerRadius</li><li>UIBezierPath</li><li>Core Graphics(为 UIView 加圆角)与直接截取图片(为 UIImageView 加圆角)</li></ol><p>如下是这三种方法的比较：</p><h5 id="1-cornerRadius"><a href="#1-cornerRadius" class="headerlink" title="1. cornerRadius"></a>1. cornerRadius</h5><pre><code>view.layer.cornerRadius = 6.0;view.layer.masksToBounds = YES;</code></pre><p>这种方式会触发两次离屏渲染，如果在滚动页面中这么做的话就会遇到性能问题。当然我们可以进行缓存以优化性能，如下:</p><pre><code>view.layer.shouldRasterize = YES;view.layer.rasterizationScale = [UIScreen mainScreen].scale;</code></pre><p><code>shouldRasterize = YES</code> 会使视图渲染内容被缓存起来，下次绘制的时候可以直接显示缓存，当然要在视图内容不改变的情况下。</p><p>注意：png 图片 在 UIImageView 这样处理圆角是不会产生离屏渲染的。（ios9.0之后不会离屏渲染，ios9.0之前还是会离屏渲染）。</p><h5 id="2-UIBezierPath"><a href="#2-UIBezierPath" class="headerlink" title="2. UIBezierPath"></a>2. UIBezierPath</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">  CGRect <span class="keyword">bounds </span>= <span class="keyword">self.bounds;</span></span><br><span class="line"><span class="keyword"> </span> [[UIBezierPath <span class="keyword">bezierPathWithRoundedRect:rect </span>cornerRadius:<span class="number">8</span>.<span class="number">0</span>] <span class="keyword">addClip];</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span> [<span class="keyword">self.image </span>drawInRect:<span class="keyword">bounds];</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>这种方法会触发一次离屏渲染，很多资料推崇这种写法，但是这种方式会导致内存暴增，并且同样会触发离屏渲染。</p><h5 id="3-Core-Graphics-为-UIView-加圆角-与直接截取图片-为-UIImageView-加圆角"><a href="#3-Core-Graphics-为-UIView-加圆角-与直接截取图片-为-UIImageView-加圆角" class="headerlink" title="3. Core Graphics(为 UIView 加圆角)与直接截取图片(为 UIImageView 加圆角)"></a>3. Core Graphics(为 UIView 加圆角)与直接截取图片(为 UIImageView 加圆角)</h5><p>正如你所期待的那样，这种方法应该是极具效率的正确的姿势。这里将为 UIView 添加圆角与为 UIImageView 添加圆角进行区分。使用 Core Graphics 为 UIView 加圆角<br>这种做法的原理是利用 Core Graphics 自己画出了一个圆角矩形。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func kt_drawRectWithRoundedCorner(radius radius: <span class="built_in">CGFloat</span>,  </span><br><span class="line">                                  borderWidth: <span class="built_in">CGFloat</span>,</span><br><span class="line">                                  backgroundColor: <span class="built_in">UIColor</span>,</span><br><span class="line">                                  borderColor: <span class="built_in">UIColor</span>) -&gt; <span class="built_in">UIImage</span> &#123;    </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(sizeToFit, <span class="literal">false</span>, <span class="built_in">UIScreen</span>.mainScreen().scale)</span><br><span class="line">    let context = <span class="built_in">UIGraphicsGetCurrentContext</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, 开始位置);  <span class="comment">// 开始坐标右边开始</span></span><br><span class="line">    <span class="built_in">CGContextAddArcToPoint</span>(context, x1, y1, x2, y2, radius);  <span class="comment">// 这种类型的代码重复四次</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextDrawPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(), .FillStroke)</span><br><span class="line">    let output = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回的是 UIImage，有了这个图片后，就可以创建一个 UIImageView 并插入到视图层级的底部：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">kt_addCorner</span><span class="params">(radius radius: CGFloat,</span></span></span><br><span class="line"><span class="function"><span class="params">                      borderWidth: CGFloat,</span></span></span><br><span class="line"><span class="function"><span class="params">                      backgroundColor: UIColor,</span></span></span><br><span class="line"><span class="function"><span class="params">                      borderColor: UIColor)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> imageView = <span class="type">UIImageView</span>(image: kt_drawRectWithRoundedCorner(radius: radius,</span><br><span class="line">                                    borderWidth: borderWidth,</span><br><span class="line">                                    backgroundColor: backgroundColor,</span><br><span class="line">                                    borderColor: borderColor))</span><br><span class="line">        <span class="keyword">self</span>.insertSubview(imageView, atIndex: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用时 只需要像这样写：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">view</span> = UIView(frame: CGRectMake(<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>))  </span><br><span class="line"><span class="built_in">view</span>.kt_addCorner(<span class="built_in">radius</span>: <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>直接截取图片为 UIImageView 加圆角<br>这里的实现思路是直接截取图片：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">UIImage</span> &#123;  </span><br><span class="line">    func kt_drawRectWithRoundedCorner(radius radius: <span class="built_in">CGFloat</span>, _ sizetoFit: <span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">        let rect = <span class="built_in">CGRect</span>(origin: <span class="built_in">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), size: sizetoFit)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">false</span>, <span class="built_in">UIScreen</span>.mainScreen().scale)</span><br><span class="line">        <span class="built_in">CGContextAddPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(),</span><br><span class="line">            <span class="built_in">UIBezierPath</span>(roundedRect: rect, byRoundingCorners: <span class="built_in">UIRectCorner</span>.AllCorners,</span><br><span class="line">                cornerRadii: <span class="built_in">CGSize</span>(width: radius, height: radius)).CGPath)</span><br><span class="line">        <span class="built_in">CGContextClip</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.drawInRect(rect)</span><br><span class="line">        <span class="built_in">CGContextDrawPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(), .FillStroke)</span><br><span class="line">        let output = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>圆角路径直接用贝塞尔曲线绘制。这个函数的效果是将原来的 UIImage 剪裁出圆角。配合着这函数，我们可以为 UIImageView 拓展一个设置圆角的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImageView</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     / !!!只有当 imageView 不为nil 时，调用此方法才有效果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     :param: radius 圆角半径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">kt_addCorner</span><span class="params">(radius radius: CGFloat)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.image = <span class="keyword">self</span>.image?.kt_drawRectWithRoundedCorner(radius: radius, <span class="keyword">self</span>.bounds.size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用时只需要像如下这样写：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> imageView = <span class="built_in">let</span> imgView1 = UIImageView(<span class="built_in">image</span>: UIImage(name: <span class="string">""</span>))  </span><br><span class="line">imageView.kt_addCorner(<span class="built_in">radius</span>: <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>注意：需要小心使用背景颜色。因为没有设置 masksToBounds，因此超出圆角的部分依然会被显示。因此不应该再使用背景颜色，可以在绘制圆角矩形时设置填充颜色来达到类似效果。</p><p>总结</p><p>∙ 如果能够只用 cornerRadius 解决问题，就不用优化。<br>∙ 如果必须设置 masksToBounds，可以参考圆角视图的数量，如果数量较少（一页只有几个）也可以考虑不用优化。<br>∙ UIImageView 的圆角通过直接截取图片实现，其它视图的圆角可以通过 Core Graphics 画出圆角矩形实现。</p>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 技术细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 离屏渲染 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AutoLayout 的原理性能</title>
      <link href="/2018/05/25/AutoLayout%E7%9A%84%E5%8E%9F%E7%90%86%E6%80%A7%E8%83%BD/"/>
      <url>/2018/05/25/AutoLayout%E7%9A%84%E5%8E%9F%E7%90%86%E6%80%A7%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>Auto Layout ，是苹果公司提供的一个基于约束布局，动态计算视图大小和位置的库，并且已经集成到了 Xcode 开发环境里。但是Auto Layout的具体的性能跟易用性到底如何呢,咱们详细的分析一下!</p><a id="more"></a><p>在引入 Auto Layout 这种自动布局方式之前，iOS 开发都是采用手动布局的方式。而手动布局的方式，原始落后、界面开发维护效率低. 所以，苹果需要提供更好的界面引擎来提升开发者的体验，Auto Layout 随之出现。</p><p>苹果公司早在 iOS 6 系统时就引入了 Auto Layout，但是直到现在还有很多开发者迟迟不愿使用 它，其原因就在于对其性能的担忧。即使后来，苹果公司推出了在 Auto Layout 基础上模仿前端 Flexbox 布局思路的 UIStackView 工具，提高了开发体验和效率，也无法解除开发者们对其性能的顾虑。那么我认为有以下三个问题会是你迫切想知道的:</p><h5 id="1-Auto-Layout-到底是如何实现自动布局的，这种布局算法真的会影响性能吗？"><a href="#1-Auto-Layout-到底是如何实现自动布局的，这种布局算法真的会影响性能吗？" class="headerlink" title="1. Auto Layout 到底是如何实现自动布局的，这种布局算法真的会影响性能吗？"></a><a href="#1">1. Auto Layout 到底是如何实现自动布局的，这种布局算法真的会影响性能吗？</a></h5><h5 id="2-Apple在-WWDC-2018-中介绍说：-iOS-12-将大幅提高-Auto-Layout-性能，使滑动达到满帧，这是如何做到的呢？"><a href="#2-Apple在-WWDC-2018-中介绍说：-iOS-12-将大幅提高-Auto-Layout-性能，使滑动达到满帧，这是如何做到的呢？" class="headerlink" title="2. Apple在 WWDC 2018 中介绍说： iOS 12 将大幅提高 Auto Layout 性能，使滑动达到满帧，这是如何做到的呢？"></a><a href="#2">2. Apple在 WWDC 2018 中介绍说： iOS 12 将大幅提高 Auto Layout 性能，使滑动达到满帧，这是如何做到的呢？</a></h5><h5 id="3-我们应该选择继续手动布局还是选择-Auto-Layout-呢？"><a href="#3-我们应该选择继续手动布局还是选择-Auto-Layout-呢？" class="headerlink" title="3. 我们应该选择继续手动布局还是选择 Auto Layout 呢？"></a><a href="#3">3. 我们应该选择继续手动布局还是选择 Auto Layout 呢？</a></h5><p>先让我我们了解下Auto Layout的来历:</p><ol><li>1997年AutoLayout用到的布局算法Cassowary被发明出来.</li><li>2011年,Apple将Cassowary算法用到了自家的布局引擎AutoLayout中.</li></ol><p>Cassowary 能够有效解析线性等式系统和线性不等式系统，用来表示用户界面的相等和相对关系。基于此，Cassowary 制定了一种规则，通过约束来描述视图间的关系。这个规则能够表示出一个视图相对于另一个视图的位置。Cassowary 算法让视图布局通过相对位置简化，简单的相对位置描述可以在运行时动态地计算出视图具体的位置。视图位置的写法简化了，界面相关代码也就更易于维护。简单来说, Cassowary通过将布局问题抽象成线性不等式，并分解成多个位置间的约束，解决了用户界面的布局问题.苹果公司也是看重了这一点，将其引入到了自己的系统中。下面就让我们分析上面的三个问题:</p><p>Auto Layout 不只有布局算法 Cassowary，还包含了布局在运行时的生命周期等一整套布局引擎系统，用来统一管理布局的创建、更新和销毁。了解 Auto Layout 的生命周期，是理解它的性能相关话题的基础。这样，在遇到问题，特别是性能问题时，我们才能从根儿上找到原因，从而避免或改进类似的问题。</p><p>这一整套布局引擎系统叫作 Layout Engine ，是 Auto Layout 的核心，主导着整个界面布局。<br>每个视图在得到自己的布局之前，Layout Engine 会将视图、约束、优先级、固定大小通过计算转换成最终的大小和位置。在 Layout Engine 里，每当约束发生变化，就会触发 Deferred Layout Pass(延迟布局传递)，完成后进入监听约束变化的状态。当再次监听到约束变化，即进入下一轮循环中。整个过程如下图所示：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4kfh6gd1sj31410u0teh.jpg" alt="Layout Engine 界面布局过程"></p><center>Layout Engine 界面布局过程</center><p>图中， Constraints Change 表示的就是约束变化，添加、删除视图时会触发约束变化。Activating 或 Deactivating，设置 Constant 或 Priority 时也会触发约束变化。Layout Engine 在碰到约束变化后会重新计算布局，获取到布局后调用 superview.setNeedLayout()，然后进入 Deferred Layout Pass。Deferred Layout Pass 的主要作用是做容错处理。如果有些视图在更新约束时没有确定或缺失布局声明的话，会先在这里做容错处理。</p><p>接下来，Layout Engine 会从上到下调用 layoutSubviews() ，通过 Cassowary 算法计算各个子视图的位置，算出来后将子视图的 frame 从 Layout Engine 里拷贝出来。在这之后的处理，就和手写布局的绘制、渲染过程一样了。所以，使用 Auto Layout 和手写布局的区别，就是多了布局上的这个计算过程。</p><p>关于界面的渲染我感觉有必要在这里说下 Render Loop.<br>Render Loop 是一个每秒钟跑120次的一个进程，是为了确保所有的内容都能为每一个frame做好准备。Render Loop 一共包括三个步骤来更新约束，布局和渲染。</p><p>首先，每一个需要接收到更新约束的 view 会从子 view 向上传递，直到 window; 然后，每一个接收到的 view 开始 layoutsubviews，和更新约束是从相反的方向开始，layout 从 window 开始到每一个子 view 进行 layout。最后，每一个需要渲染的 view，和 layout 相同，从父 view 向子view 开始渲染。如下图:<br><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4mwo0ewpmj31cc0miq4z.jpg" alt="Render Loop的渲染方式"></p><center>Render Loop的渲染方式</center><p>Render Loop目的是为了避免重复的工作。<br>举一个例子：一个UILable 需要一个约束来描述它的大小，但是有很多属性会影响他的大小，设置它的font，text size等等都会受到影响。当一个属性改变的时候，可能text其他属性也会被重新赋值<br>，很有可能调用一堆属性的setter方法，这样效率会很低。<br>只需要调用updateConstraints 并指定好要更新的属性，Render Loop会帮助你计算好它的frame并完成渲染，从而避免多次设置的重复工作。<br><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4mwo7oqv4j31c80e2wga.jpg" alt="Render Loop的方法调用"></p><center>Render Loop的方法调用</center><p>如果是多个 Cassowary 布局，就是在 iOS 12 之前影响 Auto Layout 性能的原因吗？<br>接下来，我就跟你分析下 Auto Layout 的性能问题。Auto Layout 的性能是否有问题，我们先看看苹果公司自己是怎么说的吧。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4ldetnvirj31u90u0dgg.jpg" alt="Auto Layout 在 iOS 12 中优化后的表现"></p><center>Auto Layout 在 iOS 12 中优化后的表现</center><p>上图是 WWDC 2018 中 202 Session 里讲到的 Auto Layout 在 iOS 12 中优化后的表现。可以看到，优化后的性能，已经基本和手写布局一样可以达到性能随着视图嵌套的数量呈线性增长了。而在此之前的 Auto Layout，视图嵌套的数量对性能的影响是呈指数级增长的。所以 Auto Layout 对性能影响能大不大呢。但是，这个锅应该由 Cassowary 算法来背吗？</p><p>在 1997 年时，Cassowary 是以高效的界面线性方程求解算法被提出来的。它解决的是界面的线性规划问题，而线性规划问题的解法是 Simplex 算法。单从 Simplex 算法的复杂度来看，多数情况下是没有指数时间复杂度的。而 Cassowary 算法又是在 Simplex 算法基础上对界面关系方程进行了高效的添加、修改更新操作，不会带来时间复杂度呈指数级增长的问题。<br>那么，如果 Cassowary 算法本身没有问题的话，问题就只可能是苹果公司在 iOS 12 之前在某些情况下没有用好这个算法。</p><p>接下来，我们再看一下 WWDC 2018 中 202 Session 的 Auto Layout 在兄弟视图独立开布局的情况。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4ldezdcmsj31ts0u03z7.jpg" alt="Auto Layout 在兄弟视图独立开布局的情况"></p><center>AAuto Layout 在兄弟视图独立开布局的情况</center><p>可以看到，兄弟视图之间没有关系时，是不会出现性能呈指数增加问题的。这就表示 Cassowary 算法在添加时是高效的。但如果兄弟视图间有关系的话，在视图遍历时会不断处理和兄弟视图间的关系，这时会有修改更新计算。由此可以看出，Auto Layout 并没有用上 Cassowary 高效修改更新的特性。</p><p>实际情况是，iOS 12 之前，很多约束变化时都会重新创建一个计算引擎 NSISEnginer 将约束关系重新加进来，然后重新计算。结果就是，涉及到的约束关系变多时，新的计算引擎需要重新计算，最终导致计算量呈指数级增加。更详细的讲解，你可以参考 WWDC 2018 中 202 Session 的内容，里面完整地分析了以前的问题，以及 iOS12 的解法。总体来说， iOS12 的 Auto Layout 更多地利用了 Cassowary 算法的界面更新策略，使其真正完成了高效的界面线性策略计算。</p><p>那么，明确了 iOS 12 使得 Auto Layout 具有了和手写布局几乎相同的高性能后，你是不是就可以放心地使用 Auto Layout 了呢？ 答案是肯定的。</p><p>如果你是一名手写布局的 iOS 开发者，这是你投入 Auto Layout 布局开发的最佳时机。<br>使用 Auto Layout 一定要注意多使用 Compression Resistance Priority 和 Hugging Priority，利用优先级的设置，让布局更加灵活，代码更少，更易于维护。</p><p>Auto Layout 只是一种最基础的布局思路。在前端出现了 Flexbox 这种高级的响应式布局思路后，苹果公司也紧跟其后，基于 Auto Layout 又封装了一个类似 Flexbox 的 UIStackView，用来提高 iOS 开发响应式布局的易用性。UIStackView 会在父视图里设置子视图的排列方式，比如 Fill、Leading、Center，而不用在每个子视图中都设置自己和兄弟视图的关系，可以极大地减少你在约束关系设置上所做的重复工作，提升页面布局的体验。</p><p>Apple还对界面的顺滑做了除Auto Layout 以外的优化,但 Apple 为了让 iOS 12 变快究竟做了哪些升级呢，苹果为我们介绍了针对 iOS 12 做出的一系列改变。</p><h4>1. 改进预加载功能</h4><p>在 iOS 12 中，苹果工程师攻克了困扰用户数年的卡顿问题，他们在检查官方 App 时发现了过去丢帧的原因。在 iOS 中，用户滑动、点击屏幕的时候就需要即时渲染生成内容，比如说菜单列表或者是文档中的图形，这个生成的过程花费的时间就会导致延迟。为了降低这一延迟，苹果在 iOS 10 中引入了一个名为“Cell Pre-fetch”的功能，简单来说就是在后台预测用户的动作，然后预先加载好相应的内容，当用户确定了这个点击或滑动马上把预加载好的内容呈现上来，这样一来就不会延迟了，而且不会出现处理器负载突然加大的问题。虽然“Cell Pre-fetch”确实让 iOS 10 变快了，但是仍然没有完全解决丢帧问题，工程师们发现，当系统在预加载内容的时候，处理器也同时在渲染确定会在屏幕上呈现的那一组内容，二者同时进行就会导致 CPU 遇到瓶颈，然后两个任务就都变慢了。为了解决这一问题，苹果在 Cocoa Touch （开发者创建 iOS App 时使用的接口）中重新对任务进行了排序，在屏幕渲染任务完成之后，预加载才启动，因为前者需要马上被用户看到，更加重要。</p><h4>2. CPU响应机制升级</h4><p>除了这一点之外，CPU 也有一定的升级。此前的 iOS 设备中，在 CPU 负载很小的时候也会发生丢帧，因为在任务很少的时候 CPU 会降低频率进入怠速模式。但是如果用户突然触发了一个比较麻烦的任务，CPU 就需要一点时间反应过来然后加快频率，这一过程中就会发生延迟。而在 iOS 12 中，苹果优化了 CPU 的响应机制，能更快地从低频提升到高频，并且 iOS 12 还很聪明，不会把 CPU 的频率拉得太高，只会提供完成这个任务所需要的那个频率上，所以在完成任务之后，CPU 也能够很快将频率降到合适的怠速水平，减少电池的消耗。</p><h4>3. Auto-layout （自动布局）功能升级</h4><p>紧接着还有对 Auto-layout （自动布局）功能的升级，Auto-layout 让开发者能对 App 内的图标、文字等元素更方便地定位（比如据边框多少像素），以适应不同的屏幕尺寸。但是苹果工程师发现这个从 iOS 6 就有的功能现在看来有些过于耗费资源了，在不同的情况下， Auto-layout 使用的资源可能会呈指数级增长，比如元素在嵌套和依赖于其他元素进行放置两种状态下，耗费的资源大不相同。在 iOS 12 中，苹果大大减少了会导致指数缩放的元素，减轻了对 CPU 和 GPU 的负担。总体来看，让渲染的元素彼此独立放置、互不干扰能够减少资源消耗。</p><h4>4. 自动备份存储技术</h4><p>最后，苹果还介绍了 iOS 12 的自动备份存储技术，它可以减少应用程序运行的时候消耗的内存量。在苹果的演示中，当旧版系统渲染相同大小的彩色照片和灰度图像（只存在灰度信息的黑白照片）时，耗费的内存竟然是完全一样的，但其实这两张照片包含的信息存在显著差异，彩色照片每个像素都有色值等信息，黑白照片只有灰度信息。而在使用自动备份存储技术之后，系统会对不同文件包含的数值信息进行一个初步的判断，然后再分配合适的内存给它，不会像以前那样一视同仁地处理所有内容，这样做显然可以避免浪费内存资源。</p>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 技术细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> AutoLayout </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内存分配</title>
      <link href="/2018/05/18/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2018/05/18/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>从事iOS开发这么久了,其实很多东西是值得写下来的. 一方面是可以增加自己的理解深度,   另一方面可以让别人看到查漏补缺. 今天来简单的梳理一下iOS开发中的内存分配(不是内存管理哦😯), 是从系统方面的理解而不是数据结构方面的.</p><a id="more"></a><h3>应用的内存分区</h3><p>用一张图片来解释这个概念会更直观:</p><p><img src="https://upload-images.jianshu.io/upload_images/970779-efa594531d450226.png" alt="应用内存分区"></p><p>应用程序的内存分配主要分为5个区, 咱们从低地址向高地址叙述, 分别是:</p><h5 id="1-代码区"><a href="#1-代码区" class="headerlink" title="1.代码区"></a><a href="#1">1.代码区</a></h5><h5 id="2-常量区"><a href="#2-常量区" class="headerlink" title="2.常量区"></a><a href="#2">2.常量区</a></h5><h5 id="3-全局-静态-区"><a href="#3-全局-静态-区" class="headerlink" title="3.全局(静态)区"></a><a href="#3">3.全局(静态)区</a></h5><h5 id="4-堆区"><a href="#4-堆区" class="headerlink" title="4.堆区"></a><a href="#4">4.堆区</a></h5><h5 id="5-栈区"><a href="#5-栈区" class="headerlink" title="5.栈区"></a><a href="#5">5.栈区</a></h5><h5 id="堆-heap-和栈-stack-的几个区别"><a href="#堆-heap-和栈-stack-的几个区别" class="headerlink" title="堆(heap)和栈(stack)的几个区别:"></a><a href="#6">堆(heap)和栈(stack)的几个区别:</a></h5><h5 id="在Swift中的使用"><a href="#在Swift中的使用" class="headerlink" title="在Swift中的使用:"></a><a href="#7">在Swift中的使用:</a></h5><p>下面是对这几个区的详细解释:</p><h4 id="1">1.代码区:</h4><p>代码区是用来存放可执行文件的操作指令（存放函数的二进制代码, 也就是说是它是可执行程序在内存种的镜像。代码段需要防止在运行时被非法修改, 所以只准许读取操作, 而不允许写入（修改）操作——它是不可写的。</p><h4 id="1">2.常量区:</h4><p>常量存储区,   这是一块比较特殊的存储区,他们里面存放的是常量</p><h4 id="3">3.全局(静态)区:</h4><ul><li><p>数据区：数据段用来存放可执行文件中已初始化全局变量,换句话说就是存放程序静态分配的变量和全局变量。</p></li><li><p>BSS区：BSS段包含了程序中未初始化全局变量</p></li></ul><h4 id="4">4.堆区:</h4><p>堆是由<strong>程序员</strong>分配和释放,   用于存放进程运行中被动态分配的内存段,   它大小并不固定,   可动态扩张或缩减。当进程调用alloc等函数分配内存时,  新分配的内存就被动态添加到堆上（堆被扩张)；当利用realse释放内存时,   被释放的内存从堆中被剔除(堆被缩减）,   因为我们现在iOS基本都使用ARC来管理对象,   所以不用我们程序员来管理, 但是我们要知道这个对象存储的位置。</p><h4 id="5">5.栈区:</h4><p>栈是由<strong>编译器</strong>自动分配并释放,   用户存放程序临时创建的局部变量,   存放函数的参数值,   局部变量等。也就是说我们函数括弧<code>{}</code>中定义的变量（但不包括<code>static</code>声明的变量,   <code>static</code>意味这在数据段中存放变量. 除此以外在函数被调用时,   其参数也会被压入发起调用的进程栈中,   并且待到调用结束后,  函数的返回值也回被存放回栈中。由于栈的先进后出特点,   所以栈特别方便用来保存/恢复调用现场。从这个意义上将我们可以把栈看成一个临时数据寄存、交换的内存区。栈是向低地址扩展的数据结构,  是一块连续的内存的区域。堆是向高地址扩展的数据结构,   是不连续的内存区域。有人会问堆和栈会不会碰到一起,   他们之间间隔很大,   绝少有机会能碰到一起,   况且堆是链表方式存储！</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">8</span>;<span class="comment">//全局初始化区（数据区）</span></span><br><span class="line"><span class="built_in">NSString</span> *name;<span class="comment">//全局未初始化区（BSS区）</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *myName = <span class="string">@"Jarvis"</span>;<span class="comment">//全局（静态初始化）区</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tmpAge;<span class="comment">//栈</span></span><br><span class="line">    <span class="built_in">NSString</span> *tmpName = <span class="string">@"Jarvis"</span>;<span class="comment">//栈</span></span><br><span class="line">    <span class="built_in">NSString</span> *number = <span class="string">@"123"</span>; <span class="comment">//123在常量区,   number在栈上。</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1</span>];<span class="comment">//分配而来的8字节的区域就在堆中,   array在栈中,   指向堆区的地址</span></span><br><span class="line">    <span class="built_in">NSInteger</span> total = [<span class="keyword">self</span> getTotalNumber:<span class="number">1</span> number2:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)getTotalNumber:(<span class="built_in">NSInteger</span>)number1 number2:(<span class="built_in">NSInteger</span>)number2&#123;</span><br><span class="line">    <span class="keyword">return</span> number1 + number2;<span class="comment">//number1和number2 栈区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="6">堆(heap)和栈(stack)的几个区别:</h3><h4 id="1-申请和回收方式不同"><a href="#1-申请和回收方式不同" class="headerlink" title="1.申请和回收方式不同:"></a>1.申请和回收方式不同:</h4><p><strong>栈区:</strong> 由编译器分配和释放<br><strong>堆区:</strong> 由开发者分配和释放</p><h4 id="2-系统的处理方式不同"><a href="#2-系统的处理方式不同" class="headerlink" title="2.系统的处理方式不同:"></a>2.系统的处理方式不同:</h4><p><strong>栈区:</strong> 栈是一块空间较小,   但是运行速度很快的内存区域。栈上的内存分配遵循后进先出的原则,   通过移动栈的尾指针实现 <code>push</code>(入栈）和 <code>pop</code>(出栈）操作。我们的程序是由一个个方法组成的,   CPU 会负责调度并执行这些方法。当我们的程序执行到某个方法的时候,   需要在栈上为方法需要的内存开辟空间,   此时把栈的尾指针向栈底移动。当方法执行完毕后需要释放掉这些空间,   此时会把栈的尾指针移向栈顶,   这就完成了一次栈上的内存分配。只要栈的剩余空间大于stack 对象申请创建的空间,   操作系统就会为程序提供这段内存空间,   否则将报异常提示栈溢出.  </p><p><strong>堆区:</strong> 系统有一个记录空闲内存地址的链表,   当系统收到程序开辟空间申请时,   会遍历该链表,   寻找第一个空间大于所申请空间的堆结点,   然后将该结点从空闲结点链表中删除,   并将该结点的空间分配给程序,   另外,   对于大多数系统,   会在这块内存空间中的首地址处记录本次分配的大小,   这样才能正确的释放本内存空间。另外,   由于找到的堆结点的大小不一定正好等于申请的大小,   系统会自动的将多余的那部分重新放入空闲链表中.  </p><p>iOS使用了名为 ARC（自动引用计数）的技术。在多线程环境中,   多个线程会共享堆上的内存,   为了确保线程安全,   不得不在堆上进行加锁操作,   但是加锁操作是很耗费性能的,   你在堆上所获的的数据安全性实际上是在牺牲性能的代价下得来的。  </p><p>NSString 的对象就是stack 中的对象,   NSMutableString 的对象就是heap 中的对象。前者创建时分配的内存长度固定且不可修改；后者是分配内存长度是可变的,   可有多个owner,    适用于计数管理内存管理模式。</p><h4 id="3-申请空间大小的不同"><a href="#3-申请空间大小的不同" class="headerlink" title="3.申请空间大小的不同:"></a>3.申请空间大小的不同:</h4><p><strong>栈区:</strong> 栈是从高地址向低地址扩展的数据结构,   是一块连续的内存区域。也就是说栈顶的地址和栈的最大容量是系统预先规定好的,   栈的大小是2M,   如果申请的空间超过栈的剩余空间时,   将提示栈溢出。因此,   能从栈获得的空间较小.  </p><p><strong>堆区:</strong> 堆是从低地址向高地址扩展的数据结构,   是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的,   自然是不连续的,   而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。堆获得的空间比较灵活,   也比较大.</p><h4 id="4-分配方式不同"><a href="#4-分配方式不同" class="headerlink" title="4.分配方式不同:"></a>4.分配方式不同:</h4><p><strong>栈区:</strong> 有2种分配方式：静态分配和动态分配。静态分配是编译器完成的,   比如局部变量的分配。动态分配由<code>alloc</code>函数进行分配,   但是栈的动态分配和堆是不同的,   它的动态分配是由编译器进行释放,   无需我们手工实现。<br><strong>堆区:</strong> 堆都是动态分配的,   没有静态分配的堆。</p><h4 id="5-分配效率不同"><a href="#5-分配效率不同" class="headerlink" title="5.分配效率不同:"></a>5.分配效率不同:</h4><p><strong>栈区:</strong> 栈是操作系统提供的数据结构, 计算机会在底层对栈提供支持, 分配专门的寄存器存放栈的地址, 压栈出栈都有专门的指令执行, 这就决定了栈的效率比较高.</p><p><strong>堆区:</strong> 堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内 存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到 足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><h3 id="7">在Swift中的使用:</h3><p>Swift 中的数据类型分为引用类型（类）和值类型（枚举、结构体）。引用类型存储在 “堆” 上，值类型存储在 “栈” 上。Swift 管理引用类型采用自动引用计数（ARC）的管理方法。值类型是由处理器来管理的，不需要程序员来管理.<br>在 Swift 中，典型的有 <code>struct</code>，<code>enum</code>，以及 <code>tuple</code> 都是值类型。而平时使用的<code>Int</code>，<code>Double</code>，<code>Float</code>，<code>String</code>，<code>Array</code>，<code>Dictionary</code>，<code>Set</code> 其实都是用结构体实现的，也是值类型。Swift 中，值类型的赋值为深拷贝（Deep Copy），值语义（Value Semantics）即新对象和源对象是独立的，当改变新对象的属性，源对象不会受到影响，反之同理。</p><p>在 Swift 中，<code>class</code> 和闭包是引用类型。引用类型的赋值是浅拷贝（Shallow Copy），引用语义（Reference Semantics）即新对象和源对象的变量名不同，但其引用（指向的内存空间）是一样的，因此当使用新对象操作其内部数据时，源对象的内部数据也会受到影响。</p><p>值类型作为参数传入时，函数体内部不能修改其值。引用类型作为参数传入时，函数体内部不能修改其指向的内存地址，但是可以修改其内部的变量值。</p><p>选择值类型而不是引用类型的一个主要原因是能让你的代码变得更加简单。值类型被赋给一个变量或者常量，传给函数做参数时是它的值被拷贝的。这就让值类型在任何时候只有一个享有者，从而降低复杂度。你在任何情况下用一个值类型，都能够假设你的其他代码不会使它改变，这通常在多线程环境中很有用，如果一个线程中使用的数据被另一个线程给意外的修改了，这通常会产生非常严重的Bug，且相当难以调试。</p><p>当你的实例不会对数据进行修改的时候，值类型和引用类型看起来是完全相同的。你也许会想，写一个完全不可变的类，通过使用不可变的存储属性，以及避免暴露修改数据的接口，从而在Swift里实现一个不可变的类。事实上，大多数的Cocoa类，比如NSURL等，都被设计为不可变的类，然而，Swift当前并没有提供任何语言机制去强制申明一个类不可改变（比如子类化就能修改一个类的实现），只有结构体和枚举才是强制不可变的。</p><p>在Swift里，<code>Array</code>、<code>String</code>和<code>Dictionary</code>都是值类型，他们的行为和C语言中的<code>int</code>类似，你不需要额外做任何事情就能防止其他代码在你不知情的情况下修改数据，更重要的是，你能安全地在线程间传递它，而不需要使用同步技术。在提高安全性的前提下，这个模型将帮助你在Swift中写出更多可预知的代码。</p><p>除此之外，Swift和OC还有其他的类型对应，对应关系如下：<br><img src="http://cc.cocimg.com/api/uploads//20180619/1529376567800880.png" alt="OC和Swift对应关系图"><br>但是，对于原来OC中的数据的引用类型，swift中并没有真正的实现一套数据存储逻辑。只是内部保存了对oc对象的引用，使得swift api访问时行为逻辑和值类型一致。</p>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 技术细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 内存分配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几种常见的排序方法</title>
      <link href="/2018/04/22/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
      <url>/2018/04/22/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>写在前面:以下几种排序算法默认都是升序排列,如果有疏漏或者新增内容后续补充…</p><a id="more"></a><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a><a href="#1">1.冒泡排序</a></h4><h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a><a href="#2">2.选择排序</a></h4><h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a><a href="#3">3.插入排序</a></h4><h4 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a><a href="#4">4.快速排序</a></h4><p><br><br>下面是排序算法的原理和具体的代码实现</p><h4 id="1">1.冒泡排序</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *arr = [NSMutableArray arrayWithArray:@[@<span class="number">3</span>,@<span class="number">34</span>,@<span class="number">44</span>,@<span class="number">12</span>,@<span class="number">15</span>,@<span class="number">1</span>,@<span class="number">35</span>,@<span class="number">22</span>]];</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.count - <span class="number">1</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; arr.count - <span class="built_in">i</span> - <span class="number">1</span>; <span class="built_in">j</span>++) &#123;</span><br><span class="line">            id temp = nil;</span><br><span class="line">            <span class="keyword">if</span> ([arr[<span class="built_in">j</span>] integerValue] &gt; [arr[<span class="built_in">j</span> + <span class="number">1</span>] integerValue]) &#123;</span><br><span class="line">                temp = arr[<span class="built_in">j</span>];</span><br><span class="line">                arr[<span class="built_in">j</span>] = arr[<span class="built_in">j</span> + <span class="number">1</span>];</span><br><span class="line">                arr[<span class="built_in">j</span> + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">NSLog(@<span class="string">"冒泡升序排序: %@"</span>,arr);</span><br></pre></td></tr></table></figure><h4 id="2">2.选择排序</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *arr = [NSMutableArray arrayWithArray:@[@<span class="number">3</span>,@<span class="number">34</span>,@<span class="number">44</span>,@<span class="number">12</span>,@<span class="number">15</span>,@<span class="number">1</span>,@<span class="number">35</span>,@<span class="number">22</span>]];</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.count - <span class="number">1</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="built_in">i</span> + <span class="number">1</span>; <span class="built_in">j</span> &lt; arr.count; <span class="built_in">j</span>++) &#123;</span><br><span class="line">        id temp = nil;</span><br><span class="line">        <span class="keyword">if</span> ([arr[<span class="built_in">j</span>] integerValue] &lt; [arr[<span class="built_in">i</span>] integerValue]) &#123;</span><br><span class="line">            temp = arr[<span class="built_in">i</span>];</span><br><span class="line">            arr[<span class="built_in">i</span>] = arr[<span class="built_in">j</span>];</span><br><span class="line">            arr[<span class="built_in">j</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@<span class="string">"选择升序排序: %@"</span>,arr);</span><br></pre></td></tr></table></figure><h4 id="3">3.插入排序</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *arr = [NSMutableArray  arrayWithArray:@[@<span class="number">3</span>,@<span class="number">34</span>,@<span class="number">44</span>,@<span class="number">12</span>,@<span class="number">15</span>,@<span class="number">1</span>,@<span class="number">35</span>,@<span class="number">22</span>]];</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt; arr.count; <span class="built_in">i</span>++) &#123;</span><br><span class="line">    id num = arr[<span class="built_in">i</span>];</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">j</span> =  <span class="built_in">i</span> - <span class="number">1</span>; <span class="built_in">j</span> &gt;= <span class="number">0</span> &amp;&amp; [num integerValue] &lt; [arr[<span class="built_in">j</span>] integerValue]; <span class="built_in">j</span>--) &#123;</span><br><span class="line">        arr[<span class="built_in">j</span> + <span class="number">1</span>] = arr[<span class="built_in">j</span>];</span><br><span class="line">        arr[<span class="built_in">j</span>] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@<span class="string">"插入升序排序: %@"</span>,arr);</span><br></pre></td></tr></table></figure><h4 id="4">4.快速排序</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)quickSort &#123;</span><br><span class="line">    NSMutableArray *arr = [NSMutableArray <span class="string">arrayWithArray:</span>@[@<span class="number">3</span>,@<span class="number">34</span>,@<span class="number">44</span>,@<span class="number">12</span>,@<span class="number">15</span>,@<span class="number">1</span>,@<span class="number">35</span>,@<span class="number">22</span>]];</span><br><span class="line">    [self <span class="string">quickSortArray:</span>arr <span class="string">withLeftIndex:</span><span class="number">0</span> <span class="string">andRightIndex:</span>arr.count - <span class="number">1</span>];</span><br><span class="line">    NSLog(@<span class="string">"快速升序排序: %@"</span>,arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">quickSortArray:</span>(NSMutableArray *)array <span class="string">withLeftIndex:</span>(NSInteger)leftIndex <span class="string">andRightIndex:</span>(NSInteger)rightIndex &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftIndex &gt;= rightIndex) &#123;</span><br><span class="line">    <span class="comment">//如果数组长度为0或1时返回</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSInteger i = leftIndex;</span><br><span class="line">    NSInteger j = rightIndex;</span><br><span class="line">    <span class="comment">//记录比较基准数</span></span><br><span class="line">    NSInteger key = [array[i] integerValue];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 首先从右边j开始查找比基准数小的值,如果比基准数大，继续查找</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; [array[j] integerValue] &gt;= key) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果比基准数小，则将查找到的小值调换到i的位置</span></span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当在右边查找到一个比基准数小的值时，就从i开始往后找比基准数大的值</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; [array[i] integerValue] &lt;= key) &#123;</span><br><span class="line">        <span class="comment">//如果比基准数小，继续查找</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果比基准数大，则将查找到的大值调换到j的位置</span></span><br><span class="line">        array[j] = array[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将基准数放到正确位置</span></span><br><span class="line">    array[i] = @(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归排序</span></span><br><span class="line">    <span class="comment">//排序基准数左边的</span></span><br><span class="line">    [self <span class="string">quickSortArray:</span>array <span class="string">withLeftIndex:</span>leftIndex <span class="string">andRightIndex:</span>i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//排序基准数右边的</span></span><br><span class="line">    [self <span class="string">quickSortArray:</span>array <span class="string">withLeftIndex:</span>i + <span class="number">1</span> <span class="string">andRightIndex:</span>rightIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 常见排序算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>探讨分类和类扩展</title>
      <link href="/2017/08/12/%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/"/>
      <url>/2017/08/12/%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<p>  在最初学习<code>category</code>和<code>extension</code>的时候感觉很是头大，什么是分类，什么是类扩展，他们分别用在什么场合，各有哪些特点？后来随着自己的深入了解，发现这真的是很出色的两种扩展。希望把自己的经验写出来，让更多人能够理解分类和类扩展，并实际运用他们。</p><a id="more"></a><p>分类运用场景举例：想要收集每个页面的启动时间。</p><h4 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h4><p>问题:<br>项目中已经有上百个页面了，如果一个一个的加，浪费时间不说，以后增加了新页面，还需要添加方法。</p><p>解决方法:<br>我们可以发现页面都继承了<code>UIViewController</code>，想要在每个页面都执行的代码，可以写在这些页面的父类中。我们可以把代码写在<code>UIViewController</code>中。</p><h4 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h4><p>问题:<br><code>UIViewController</code>是官方类，我们只能调用期接口，并不能修改他的实现。</p><p>解决方法:<br>使用分类（category）。</p><h4 id="关于分类的一些重点"><a href="#关于分类的一些重点" class="headerlink" title="关于分类的一些重点"></a>关于分类的一些重点</h4><h5 id="分类category的作用"><a href="#分类category的作用" class="headerlink" title="分类category的作用"></a>分类<code>category</code>的作用</h5><ul><li>作用：可以在不修改原来类的基础上，为一个类扩展方法。</li><li>最主要的用法：给系统自带的类扩展方法。</li></ul><h5 id="分类category中能写点啥-？"><a href="#分类category中能写点啥-？" class="headerlink" title="分类category中能写点啥 ？"></a>分类<code>category</code>中能写点啥 ？</h5><ul><li>分类中只能添加“方法”，不能增加成员变量。</li><li>分类中可以访问原来类中的成员变量，但是只能访问<code>@protect</code>和<code>@public</code>形式的变量。如果想要访问本类中的私有变量，分类和子类一样，只能通过方法来访问。</li><li>如果一定要在分类中添加成员变量，可以通过<code>getter</code>，<code>setter</code>手段进行添加，详细以后再写</li></ul><h5 id="分类的创建方法"><a href="#分类的创建方法" class="headerlink" title="分类的创建方法"></a>分类的创建方法</h5><p>分类的创建方法如下图:<br><img src="https://ws1.sinaimg.cn/large/006tKfTcly1ft6xmneeclj30ou05sjrd.jpg" alt="分类的创建方法"></p><h5 id="分类的书写方法"><a href="#分类的书写方法" class="headerlink" title="分类的书写方法"></a>分类的书写方法</h5><p>  假设我们有一个类，名叫<code>Person</code>，意义是人类。在<code>person</code>类中我们有一个方法，<code>-(void)eat;</code>意义是吃，因为每个人类都会吃。<br>人类有非常多的共同属性,也有非常多的不同属性。有的人会说英语有的人就不会,所以我们给会说英语的人添加一个说英语的分类<code>speakEnglish</code>因为是<code>Person</code>类的分类，你会看到生成的名字叫做<code>Person+ speakEnglish</code>。下面让我们来试着添加一下。</p><ul><li>分类的使用过程：声明分类-&gt;实现分类-&gt;使用分类</li><li>在项目中添加类，选择Objective-C File，填写分类的类名 -&gt; 选择文件类型是分类 -&gt; 选择类</li><li>在<code>类名 + 分类名称.h</code>中声明方法</li><li>在<code>类名 + 分类名称.m</code>中实现方法</li></ul><!--第四: 回到最开始收集页面启动时间的问题，本类是系统的类，这里是UIViewController，我们可以使用分类扩展他的方法，也可以重写他的方法，可以我需要在调用的地方加头文件，所有子类都写头文件和直接在子类写方法没有什么区别，怎么样可以使得不写头文件，子类就能调用我们写的代码呢？回答：我们可以进行方法交换（这样可以不必在调用的地方增加头文件），从而使得在实现的时候调用重写的方法。具体实现以后会写，TODO--><h5 id="分类的执行优先级"><a href="#分类的执行优先级" class="headerlink" title="分类的执行优先级"></a>分类的执行优先级</h5><ul><li>在本类和分类有相同的方法时，优先调用分类的方法再调用本类的方法。</li><li>如果有两个分类，他们都实现了相同的方法，如何判断谁先执行？分类执行顺序可以通过<code>targets,Build Phases,Complie Source</code>进行调节，注意执行顺序是从上到下的。（只有两个相同方法名的分类）</li></ul><h5 id="分类category和类扩展extension的关系"><a href="#分类category和类扩展extension的关系" class="headerlink" title="分类category和类扩展extension的关系"></a>分类<code>category</code>和类扩展<code>extension</code>的关系</h5><ul><li>类扩展<code>extension</code>是<code>category</code>的一个特例，有时候也被称为匿名分类。他的作用是为一个类添加一些私有的成员变量和方法。</li><li>类扩展能写点啥？和分类不同，类扩展即可以声明成员变量又可以声明方法。</li><li>类扩展听上去很复杂，但其实我们很早就认识他了。你记得继承自<code>UIViewController</code>的<code>ViewController</code>和继承自<code>NSObject</code>的类有什么不同么？<br>继承自<code>UIViewController</code>的<code>ViewController</code>类,对比看一下继承自<code>NSObject</code>的类我们会发现没有下面的代码块<br>  <code>@interface ViewController()</code><font color="#006600">&emsp;&emsp;//这就是类扩展的写法</font><br> <code>@end</code></li><li>类扩展可以定义在<code>.m</code>文件中，这种扩展方式中定义的变量都是私有的，也可以定义在<code>.h</code>文件中，这样定义的代码就是共有的，类扩展在<code>.m</code>文件中声明私有方法是非常好的方式。</li><li>类扩展中添加的新方法，一定要实现,<code>category</code>中没有这种限制。</li></ul>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 技术细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 分类和扩展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS中 typedef 和 define 理解</title>
      <link href="/2017/06/07/typedef%20%E5%92%8C%20define%20%E7%9A%84%E5%BE%AE%E8%A7%A3%E9%87%8A/"/>
      <url>/2017/06/07/typedef%20%E5%92%8C%20define%20%E7%9A%84%E5%BE%AE%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[<p>写在前面,学习iOS开发的过程中会遇到一些很细节的问题,但是这些问题对于开发和学习又很重要所以就把这些东西记录下来方便回顾和分享给大家,本章主要讨论 <code>define</code> ,<code>typedef</code>的区别.</p><a id="more"></a><h4 id="1-typedef-类型定义"><a href="#1-typedef-类型定义" class="headerlink" title="1. typedef 类型定义"></a>1. <code>typedef</code> 类型定义</h4><p>作用: 类型替换: 就是把复杂类型改一个简单的名字.</p><p>示例:</p><p><font color="#006600"> // 给float取别名为floatX</font><br><code>typedef float floatX;</code> </p><p><font color="#006600"> // 给block取别名passBlock</font><br><code>typedef void(^passBlock) (int a,int b);</code></p><p><font color="#006600"> // 给PersonObject结构体取别名为person。使用方法: person p = {“Jarvis”};</font><br><code>typedef struct PersonObject{    NSString *name;}person;</code></p><h4 id="2-define-宏定义"><a href="#2-define-宏定义" class="headerlink" title="2. define 宏定义"></a>2. <code>define</code> 宏定义</h4><p>作用: 文本替换: 把出现的文本替换为定义的文本.</p><p>示例:</p><p><font color="#006600"> // kSayHello 替换后面的文本</font><br><code>#define kSayHello @&quot;Hello World !&quot;</code></p><p><font color="#006600"> // kSayHelloTwo 替换 kSayHello</font><br><code>#define kSayHelloTwo kSayHello</code></p><h4 id="3-define和typedef的使用注意事项"><a href="#3-define和typedef的使用注意事项" class="headerlink" title="3. define和typedef的使用注意事项"></a>3. <code>define</code>和<code>typedef</code>的使用注意事项</h4><ul><li><p><code>define</code> 是文本替换，是预编译指令，本身不参与编译，除非希望替换的文本中有<code>;</code>否则不用加<code>;</code><br><code>typedef</code> 是类型替换，语句的一种，结尾必须有<code>;</code></p></li><li><p><code>define</code> 在方法/函数中则作用域从写的地方开始有效，直至使用<code>#undef</code>（不写此指令则后面一直有效）。<code>typedef</code> 写在方法/函数中则作用域 只在此方法/函数中有效。</p></li><li><p>若使用<code>typedef char * MyString;</code>则 <code>MyString s1,s2</code> 等价于  <code>char *s1</code>; <code>char *s2</code></p></li><li><p>若使用 <code>#define MyString char *</code> 则 <code>MyString s1,s2</code> 等价于<code>char *s1,s2</code> 即 <code>char *s1</code>; <code>char s2</code></p></li><li><p>再次说明了<code>typedef</code>是类型替换，直接参与编译，而<code>define</code>只是简单的文本替换.</p></li></ul>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 技术细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> typedef和define </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象的六大原则</title>
      <link href="/2017/03/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2017/03/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<p>思想是编程的灵魂,面向对象的编程思想,各种设计模式掌握的好才能写出稳健,易用,扩展性好,测试性好的代码.<br><a id="more"></a></p><h5 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1.单一职责原则 (SRP)"></a>1.单一职责原则 (SRP)</h5><blockquote><p><strong>定义:</strong>      对于一个类来说,引起它变化的原因应该只有一个</p><p><strong>解释:</strong>  一个类是一组相关性很高的函数,一个类尽量只实现一个功能</p></blockquote><h5 id="2-开闭原则-OCP"><a href="#2-开闭原则-OCP" class="headerlink" title="2.开闭原则 (OCP)"></a>2.开闭原则 (OCP)</h5><blockquote><p><strong>定义:</strong>  程序中的对象应该是扩展开放,对修改封闭.这个原则同样也适合于控件的封装.</p><p><strong>解释:</strong>  当一个类实现了一个功能,想要增加新的功能或者改变这个功能的时候不是去修改这个类而是通过扩展来实现.实现该类的接口方法来实现扩展,或者使用集成或分类来实现.</p></blockquote><h5 id="3-里氏替换原则-LSP"><a href="#3-里氏替换原则-LSP" class="headerlink" title="3.里氏替换原则 (LSP)"></a>3.里氏替换原则 (LSP)</h5><blockquote><p><strong>定义:</strong>  使用基类的地方必须能使用其子类对象</p><p><strong>解释:</strong>  只要父类能出现的地方子类就可以使用,替换为子类也不会产生错误.开闭原则可以通过里氏替换原则来实现.</p></blockquote><h5 id="4-依赖倒置原则-DIP"><a href="#4-依赖倒置原则-DIP" class="headerlink" title="4.依赖倒置原则 (DIP)"></a>4.依赖倒置原则 (DIP)</h5><blockquote><p><strong>定义:</strong>  模块间依赖抽象化</p><p><strong>解释:</strong>  模块间通过抽象依赖,实体类之间不直接发生依赖关系,其依赖关系是通过接口或者抽象类产生.</p></blockquote><h5 id="5-接口隔离原则-ISP"><a href="#5-接口隔离原则-ISP" class="headerlink" title="5.接口隔离原则 (ISP)"></a>5.接口隔离原则 (ISP)</h5><blockquote><p><strong>定义:</strong>  类或者模块不应该依赖它不需要的接口</p><p><strong>解释:</strong>  接口隔离可以使系统解耦合,更容易更改或者重构,对其他模块造成的影响最小.</p></blockquote><h5 id="6-迪米特原则-LOD"><a href="#6-迪米特原则-LOD" class="headerlink" title="6.迪米特原则 (LOD)"></a>6.迪米特原则 (LOD)</h5><blockquote><p><strong>定义:</strong>  一个对象对其他对象了解的越少越好</p><p><strong>解释:</strong>  一个类应该对引用的类知道的越少越好,类的内部实现与调用者没有关系</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 面向对象原则 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发牛人博客</title>
      <link href="/2016/02/08/iOS%E5%BC%80%E5%8F%91%E7%89%9B%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2016/02/08/iOS%E5%BC%80%E5%8F%91%E7%89%9B%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>学习iOS开发的过程总是想看看牛人们的学习和工作方式,收藏一些牛人的博客供学习!</p><a id="more"></a><ul><li>王巍的博客：<a href="http://onevcat.com" target="_blank" rel="noopener">http://onevcat.com</a></li><li>池建强的博客：<a href="http://macshuo.com" target="_blank" rel="noopener">http://macshuo.com</a></li><li>唐巧的博客：<a href="http://blog.devtang.com" target="_blank" rel="noopener">http://blog.devtang.com</a></li><li>许小帅的博客：<a href="http://imallen.com" target="_blank" rel="noopener">http://imallen.com</a></li><li>蓝晨钰的博客：<a href="http://gracelancy.com" target="_blank" rel="noopener">http://gracelancy.com</a></li><li>萧宸宇的博客：<a href="http://iiiyu.com" target="_blank" rel="noopener">http://iiiyu.com</a></li><li>陶丰平的博客：<a href="http://www.taofengping.com" target="_blank" rel="noopener">http://www.taofengping.com</a></li><li>乔学士的博客：<a href="http://joeyio.com" target="_blank" rel="noopener">http://joeyio.com</a></li><li>破船的博客: <a href="http://beyondvincent.com" target="_blank" rel="noopener">http://beyondvincent.com</a></li><li>陈咏聪的博客：<a href="http://vinqon.com" target="_blank" rel="noopener">http://vinqon.com</a></li><li>骆仕恺的博客: <a href="http://luosky.com" target="_blank" rel="noopener">http://luosky.com</a></li><li>耿健桓的博客：<a href="http://dlog.dismory.com" target="_blank" rel="noopener">http://dlog.dismory.com</a></li><li>李择一的博客：<a href="http://cnblogs.com/biosli" target="_blank" rel="noopener">http://cnblogs.com/biosli</a></li><li>王轲的博客：<a href="http://www.iwangke.me" target="_blank" rel="noopener">http://www.iwangke.me</a></li><li>杨宇建的博客：<a href="http://www.cnblogs.com/easonoutlook" target="_blank" rel="noopener">http://www.cnblogs.com/easonoutlook</a></li><li>连栩的博客： <a href="http://lianxu.me" target="_blank" rel="noopener">http://lianxu.me</a></li><li>高嘉峻的博客：<a href="http://jiajun.org" target="_blank" rel="noopener">http://jiajun.org</a></li><li>webfrogs的博客：<a href="http://webfrogs.me" target="_blank" rel="noopener">http://webfrogs.me</a></li><li>sunny的博客：<a href="http://blog.sunnyxx.com" target="_blank" rel="noopener">http://blog.sunnyxx.com</a></li><li>景总的博客：<a href="http://blog.csdn.net/justinjing0612" target="_blank" rel="noopener">http://blog.csdn.net/justinjing0612</a></li><li>谭灏的博客：<a href="http://tanhao.me" target="_blank" rel="noopener">http://tanhao.me</a></li><li>田伟宇的博客：<a href="http://casatwy.com" target="_blank" rel="noopener">http://casatwy.com</a></li><li>念茜的博客: <a href="http://nianxi.net" target="_blank" rel="noopener">http://nianxi.net</a></li></ul><p>目前收录这么多牛人博客,后序再慢慢添加! 如果大家有好的博客,欢迎推荐!!</p>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 技术提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 牛人博客 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>简介</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>参加过多个产品的设计,交互,技术定型,开发,发布等完成的开发流程.具有快速学习的能力和沟通能力，能够快速融入团队,喜欢钻研新技术，更把新技术完美运用到项目中为乐趣,对工作和生活有很强的责任心,认真对待做的每一件事情.</p><h4 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h4><p> 邮箱: zjm100163@163.com</p>]]></content>
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
