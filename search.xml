<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>几种常见的排序方法</title>
      <link href="/2014/04/08/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
      <url>/2014/04/08/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>写在前面:以下几种排序算法默认都是升序排列,如果有疏漏或者新增内容后续补充…</p><a id="more"></a><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a><a href="#1">1.冒泡排序</a></h4><h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a><a href="#2">2.选择排序</a></h4><h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a><a href="#3">3.插入排序</a></h4><h4 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a><a href="#4">4.快速排序</a></h4><p><br><br>下面是排序算法的原理和具体的代码实现</p><h4 id="1">1.冒泡排序</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *arr = [NSMutableArray arrayWithArray:@[@<span class="number">3</span>,@<span class="number">34</span>,@<span class="number">44</span>,@<span class="number">12</span>,@<span class="number">15</span>,@<span class="number">1</span>,@<span class="number">35</span>,@<span class="number">22</span>]];</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.count - <span class="number">1</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; arr.count - <span class="built_in">i</span> - <span class="number">1</span>; <span class="built_in">j</span>++) &#123;</span><br><span class="line">            id temp = nil;</span><br><span class="line">            <span class="keyword">if</span> ([arr[<span class="built_in">j</span>] integerValue] &gt; [arr[<span class="built_in">j</span> + <span class="number">1</span>] integerValue]) &#123;</span><br><span class="line">                temp = arr[<span class="built_in">j</span>];</span><br><span class="line">                arr[<span class="built_in">j</span>] = arr[<span class="built_in">j</span> + <span class="number">1</span>];</span><br><span class="line">                arr[<span class="built_in">j</span> + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@<span class="string">"冒泡升序排序: %@"</span>,arr);</span><br></pre></td></tr></table></figure><h4 id="2">2.选择排序</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *arr = [NSMutableArray arrayWithArray:@[@<span class="number">3</span>,@<span class="number">34</span>,@<span class="number">44</span>,@<span class="number">12</span>,@<span class="number">15</span>,@<span class="number">1</span>,@<span class="number">35</span>,@<span class="number">22</span>]];</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.count - <span class="number">1</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="built_in">i</span> + <span class="number">1</span>; <span class="built_in">j</span> &lt; arr.count; <span class="built_in">j</span>++) &#123;</span><br><span class="line">        id temp = nil;</span><br><span class="line">        <span class="keyword">if</span> ([arr[<span class="built_in">j</span>] integerValue] &lt; [arr[<span class="built_in">i</span>] integerValue]) &#123;</span><br><span class="line">            temp = arr[<span class="built_in">i</span>];</span><br><span class="line">            arr[<span class="built_in">i</span>] = arr[<span class="built_in">j</span>];</span><br><span class="line">            arr[<span class="built_in">j</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@<span class="string">"选择升序排序: %@"</span>,arr);</span><br></pre></td></tr></table></figure><h4 id="3">3.插入排序</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *arr = [NSMutableArray  arrayWithArray:@[@<span class="number">3</span>,@<span class="number">34</span>,@<span class="number">44</span>,@<span class="number">12</span>,@<span class="number">15</span>,@<span class="number">1</span>,@<span class="number">35</span>,@<span class="number">22</span>]];</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt; arr.count; <span class="built_in">i</span>++) &#123;</span><br><span class="line">    id num = arr[<span class="built_in">i</span>];</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">j</span> =  <span class="built_in">i</span> - <span class="number">1</span>; <span class="built_in">j</span> &gt;= <span class="number">0</span> &amp;&amp; [num integerValue] &lt; [arr[<span class="built_in">j</span>] integerValue]; <span class="built_in">j</span>--) &#123;</span><br><span class="line">        arr[<span class="built_in">j</span> + <span class="number">1</span>] = arr[<span class="built_in">j</span>];</span><br><span class="line">        arr[<span class="built_in">j</span>] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@<span class="string">"插入升序排序: %@"</span>,arr);</span><br></pre></td></tr></table></figure><h4 id="4">4.快速排序</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)quickSort &#123;</span><br><span class="line">    NSMutableArray *arr = [NSMutableArray <span class="string">arrayWithArray:</span>@[@<span class="number">3</span>,@<span class="number">34</span>,@<span class="number">44</span>,@<span class="number">12</span>,@<span class="number">15</span>,@<span class="number">1</span>,@<span class="number">35</span>,@<span class="number">22</span>]];</span><br><span class="line">    [self <span class="string">quickSortArray:</span>arr <span class="string">withLeftIndex:</span><span class="number">0</span> <span class="string">andRightIndex:</span>arr.count - <span class="number">1</span>];</span><br><span class="line">    NSLog(@<span class="string">"快速升序排序: %@"</span>,arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">quickSortArray:</span>(NSMutableArray *)array <span class="string">withLeftIndex:</span>(NSInteger)leftIndex <span class="string">andRightIndex:</span>(NSInteger)rightIndex &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftIndex &gt;= rightIndex) &#123;</span><br><span class="line">    <span class="comment">//如果数组长度为0或1时返回</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSInteger i = leftIndex;</span><br><span class="line">    NSInteger j = rightIndex;</span><br><span class="line">    <span class="comment">//记录比较基准数</span></span><br><span class="line">    NSInteger key = [array[i] integerValue];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 首先从右边j开始查找比基准数小的值,如果比基准数大，继续查找</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; [array[j] integerValue] &gt;= key) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果比基准数小，则将查找到的小值调换到i的位置</span></span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当在右边查找到一个比基准数小的值时，就从i开始往后找比基准数大的值</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; [array[i] integerValue] &lt;= key) &#123;</span><br><span class="line">        <span class="comment">//如果比基准数小，继续查找</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果比基准数大，则将查找到的大值调换到j的位置</span></span><br><span class="line">        array[j] = array[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将基准数放到正确位置</span></span><br><span class="line">    array[i] = @(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归排序</span></span><br><span class="line">    <span class="comment">//排序基准数左边的</span></span><br><span class="line">    [self <span class="string">quickSortArray:</span>array <span class="string">withLeftIndex:</span>leftIndex <span class="string">andRightIndex:</span>i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//排序基准数右边的</span></span><br><span class="line">    [self <span class="string">quickSortArray:</span>array <span class="string">withLeftIndex:</span>i + <span class="number">1</span> <span class="string">andRightIndex:</span>rightIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象的六大原则</title>
      <link href="/2014/03/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2014/03/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<p>思想是编程的灵魂,面向对象的编程思想,各种设计模式掌握的好才能写出稳健,易用,扩展性好,测试性好的代码.<br><a id="more"></a></p><h5 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1.单一职责原则 (SRP)"></a>1.单一职责原则 (SRP)</h5><blockquote><p><strong>定义:</strong>      对于一个类来说,引起它变化的原因应该只有一个</p><p><strong>解释:</strong>  一个类是一组相关性很高的函数,一个类尽量只实现一个功能</p></blockquote><h5 id="2-开闭原则-OCP"><a href="#2-开闭原则-OCP" class="headerlink" title="2.开闭原则 (OCP)"></a>2.开闭原则 (OCP)</h5><blockquote><p><strong>定义:</strong>  程序中的对象应该是扩展开放,对修改封闭.这个原则同样也适合于控件的封装.</p><p><strong>解释:</strong>  当一个类实现了一个功能,想要增加新的功能或者改变这个功能的时候不是去修改这个类而是通过扩展来实现.实现该类的接口方法来实现扩展,或者使用集成或分类来实现.</p></blockquote><h5 id="3-里氏替换原则-LSP"><a href="#3-里氏替换原则-LSP" class="headerlink" title="3.里氏替换原则 (LSP)"></a>3.里氏替换原则 (LSP)</h5><blockquote><p><strong>定义:</strong>  使用基类的地方必须能使用其子类对象</p><p><strong>解释:</strong>  只要父类能出现的地方子类就可以使用,替换为子类也不会产生错误.开闭原则可以通过里氏替换原则来实现.</p></blockquote><h5 id="4-依赖倒置原则-DIP"><a href="#4-依赖倒置原则-DIP" class="headerlink" title="4.依赖倒置原则 (DIP)"></a>4.依赖倒置原则 (DIP)</h5><blockquote><p><strong>定义:</strong>  模块间依赖抽象化</p><p><strong>解释:</strong>  模块间通过抽象依赖,实体类之间不直接发生依赖关系,其依赖关系是通过接口或者抽象类产生.</p></blockquote><h5 id="5-接口隔离原则-ISP"><a href="#5-接口隔离原则-ISP" class="headerlink" title="5.接口隔离原则 (ISP)"></a>5.接口隔离原则 (ISP)</h5><blockquote><p><strong>定义:</strong>  类或者模块不应该依赖它不需要的接口</p><p><strong>解释:</strong>  接口隔离可以使系统解耦合,更容易更改或者重构,对其他模块造成的影响最小.</p></blockquote><h5 id="6-迪米特原则-LOD"><a href="#6-迪米特原则-LOD" class="headerlink" title="6.迪米特原则 (LOD)"></a>6.迪米特原则 (LOD)</h5><blockquote><p><strong>定义:</strong>  一个对象对其他对象了解的越少越好</p><p><strong>解释:</strong>  一个类应该对引用的类知道的越少越好,类的内部实现与调用者没有关系</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 编程思想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发牛人博客</title>
      <link href="/2014/02/09/iOS%E5%BC%80%E5%8F%91%E7%89%9B%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2014/02/09/iOS%E5%BC%80%E5%8F%91%E7%89%9B%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>学习iOS开发的过程总是想看看牛人们的学习和工作方式,收藏一些牛人的博客供学习!</p><a id="more"></a><ul><li>王巍的博客：<a href="http://onevcat.com" target="_blank" rel="noopener">http://onevcat.com</a></li><li>池建强的博客：<a href="http://macshuo.com" target="_blank" rel="noopener">http://macshuo.com</a></li><li>唐巧的博客：<a href="http://blog.devtang.com" target="_blank" rel="noopener">http://blog.devtang.com</a></li><li>许小帅的博客：<a href="http://imallen.com" target="_blank" rel="noopener">http://imallen.com</a></li><li>蓝晨钰的博客：<a href="http://gracelancy.com" target="_blank" rel="noopener">http://gracelancy.com</a></li><li>萧宸宇的博客：<a href="http://iiiyu.com" target="_blank" rel="noopener">http://iiiyu.com</a></li><li>陶丰平的博客：<a href="http://www.taofengping.com" target="_blank" rel="noopener">http://www.taofengping.com</a></li><li>乔学士的博客：<a href="http://joeyio.com" target="_blank" rel="noopener">http://joeyio.com</a></li><li>破船的博客: <a href="http://beyondvincent.com" target="_blank" rel="noopener">http://beyondvincent.com</a></li><li>陈咏聪的博客：<a href="http://vinqon.com" target="_blank" rel="noopener">http://vinqon.com</a></li><li>骆仕恺的博客: <a href="http://luosky.com" target="_blank" rel="noopener">http://luosky.com</a></li><li>耿健桓的博客：<a href="http://dlog.dismory.com" target="_blank" rel="noopener">http://dlog.dismory.com</a></li><li>李择一的博客：<a href="http://cnblogs.com/biosli" target="_blank" rel="noopener">http://cnblogs.com/biosli</a></li><li>王轲的博客：<a href="http://www.iwangke.me" target="_blank" rel="noopener">http://www.iwangke.me</a></li><li>杨宇建的博客：<a href="http://www.cnblogs.com/easonoutlook" target="_blank" rel="noopener">http://www.cnblogs.com/easonoutlook</a></li><li>连栩的博客： <a href="http://lianxu.me" target="_blank" rel="noopener">http://lianxu.me</a></li><li>高嘉峻的博客：<a href="http://jiajun.org" target="_blank" rel="noopener">http://jiajun.org</a></li><li>webfrogs的博客：<a href="http://webfrogs.me" target="_blank" rel="noopener">http://webfrogs.me</a></li><li>sunny的博客：<a href="http://blog.sunnyxx.com" target="_blank" rel="noopener">http://blog.sunnyxx.com</a></li><li>景总的博客：<a href="http://blog.csdn.net/justinjing0612" target="_blank" rel="noopener">http://blog.csdn.net/justinjing0612</a></li><li>谭灏的博客：<a href="http://tanhao.me" target="_blank" rel="noopener">http://tanhao.me</a></li><li>田伟宇的博客：<a href="http://casatwy.com" target="_blank" rel="noopener">http://casatwy.com</a></li><li>念茜的博客: <a href="http://nianxi.net" target="_blank" rel="noopener">http://nianxi.net</a></li></ul><p>目前收录这么多牛人博客,后序再慢慢添加! 如果大家有好的博客,欢迎推荐!!</p>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 技术提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS中 typedef 和 define 理解</title>
      <link href="/2014/02/07/typedef%20%E5%92%8C%20define%20%E7%9A%84%E5%BE%AE%E8%A7%A3%E9%87%8A/"/>
      <url>/2014/02/07/typedef%20%E5%92%8C%20define%20%E7%9A%84%E5%BE%AE%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[<p>写在前面,学习iOS开发的过程中会遇到一些很细节的问题,但是这些问题对于开发和学习又很重要所以就把这些东西记录下来方便回顾和分享给大家,本章主要讨论 <code>define</code> ,<code>typedef</code>的区别.</p><a id="more"></a><h4 id="1-define-宏定义"><a href="#1-define-宏定义" class="headerlink" title="1. define 宏定义"></a>1. <code>define</code> 宏定义</h4><p>作用: 文本替换: 把出现的文本替换为定义的文本.</p><p>示例:</p><p><font color="#006600"> // 给float取别名为floatX</font><br><code>typedef float floatX;</code> </p><p><font color="#006600"> // 给block取别名passBlock</font><br><code>typedef void(^passBlock) (int a,int b);</code></p><p><font color="#006600"> // 给PersonObject结构体取别名为person。使用方法: person p = {“Jarvis”};</font><br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PersonObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    NSString *name;</span><br><span class="line">&#125;person;</span><br></pre></td></tr></table></figure></p><h4 id="2-typedef-类型定义"><a href="#2-typedef-类型定义" class="headerlink" title="2. typedef 类型定义"></a>2. <code>typedef</code> 类型定义</h4><p>作用: 类型替换: 就是把复杂类型改一个简单的名字.</p><p>示例:</p><p><font color="#006600"> // kSayHello 替换后面的文本</font><br><code>#define kSayHello @&quot;Hello World !&quot;</code></p><p><font color="#006600"> // kSayHelloTwo 替换 kSayHello</font><br><code>#define kSayHelloTwo kSayHello</code></p><h4 id="3-define和typedef的使用注意事项"><a href="#3-define和typedef的使用注意事项" class="headerlink" title="3. define和typedef的使用注意事项"></a>3. <code>define</code>和<code>typedef</code>的使用注意事项</h4><ul><li><p><code>define</code> 是文本替换，是预编译指令，本身不参与编译，除非希望替换的文本中有<code>;</code>否则不用加<code>;</code><br><code>typedef</code> 是类型替换，语句的一种，结尾必须有<code>;</code></p></li><li><p><code>define</code> 在方法/函数中则作用域从写的地方开始有效，直至使用<code>#undef</code>（不写此指令则后面一直有效）。<code>typedef</code> 写在方法/函数中则作用域 只在此方法/函数中有效。</p></li><li><p>若使用<code>typedef char * MyString;</code>则 <code>MyString s1,s2</code> 等价于  <code>char *s1</code>; <code>char *s2</code></p></li><li><p>若使用 <code>#define MyString char *</code> 则 <code>MyString s1,s2</code> 等价于<code>char *s1,s2</code> 即 <code>char *s1</code>; <code>char s2</code></p></li><li><p>再次说明了<code>typedef</code>是类型替换，直接参与编译，而<code>define</code>只是简单的文本替换.</p></li></ul>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>探讨分类和类扩展</title>
      <link href="/2014/01/08/%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/"/>
      <url>/2014/01/08/%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<p>  在最初学习<code>category</code>和<code>extension</code>的时候感觉很是头大，什么是分类，什么是类扩展，他们分别用在什么场合，各有哪些特点？后来随着自己的深入了解，发现这真的是很出色的两种扩展。希望把自己的经验写出来，让更多人能够理解分类和类扩展，并实际运用他们。</p><a id="more"></a><p>分类运用场景举例：想要收集每个页面的启动时间。</p><h4 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h4><p>问题:<br>项目中已经有上百个页面了，如果一个一个的加，浪费时间不说，以后增加了新页面，还需要添加方法。</p><p>解决方法:<br>我们可以发现页面都继承了<code>UIViewController</code>，想要在每个页面都执行的代码，可以写在这些页面的父类中。我们可以把代码写在<code>UIViewController</code>中。</p><h4 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h4><p>问题:<br><code>UIViewController</code>是官方类，我们只能调用期接口，并不能修改他的实现。</p><p>解决方法:<br>使用分类（category）。</p><h4 id="关于分类的一些重点"><a href="#关于分类的一些重点" class="headerlink" title="关于分类的一些重点"></a>关于分类的一些重点</h4><h5 id="分类category的作用"><a href="#分类category的作用" class="headerlink" title="分类category的作用"></a>分类<code>category</code>的作用</h5><ul><li>作用：可以在不修改原来类的基础上，为一个类扩展方法。</li><li>最主要的用法：给系统自带的类扩展方法。</li></ul><h5 id="分类category中能写点啥-？"><a href="#分类category中能写点啥-？" class="headerlink" title="分类category中能写点啥 ？"></a>分类<code>category</code>中能写点啥 ？</h5><ul><li>分类中只能添加“方法”，不能增加成员变量。</li><li>分类中可以访问原来类中的成员变量，但是只能访问<code>@protect</code>和<code>@public</code>形式的变量。如果想要访问本类中的私有变量，分类和子类一样，只能通过方法来访问。</li><li>如果一定要在分类中添加成员变量，可以通过<code>getter</code>，<code>setter</code>手段进行添加，详细以后再写</li></ul><h5 id="分类的创建方法"><a href="#分类的创建方法" class="headerlink" title="分类的创建方法"></a>分类的创建方法</h5><p>分类的创建方法如下图:<br><img src="https://ws1.sinaimg.cn/large/006tKfTcly1ft6xmneeclj30ou05sjrd.jpg" alt="分类的创建方法"></p><h5 id="分类的书写方法"><a href="#分类的书写方法" class="headerlink" title="分类的书写方法"></a>分类的书写方法</h5><p>  假设我们有一个类，名叫<code>Person</code>，意义是人类。在<code>person</code>类中我们有一个方法，<code>-(void)eat;</code>意义是吃，因为每个人类都会吃。<br>人类有非常多的共同属性,也有非常多的不同属性。有的人会说英语有的人就不会,所以我们给会说英语的人添加一个说英语的分类<code>speakEnglish</code>因为是<code>Person</code>类的分类，你会看到生成的名字叫做<code>Person+ speakEnglish</code>。下面让我们来试着添加一下。</p><ul><li>分类的使用过程：声明分类-&gt;实现分类-&gt;使用分类</li><li>在项目中添加类，选择Objective-C File，填写分类的类名 -&gt; 选择文件类型是分类 -&gt; 选择类</li><li>在<code>类名 + 分类名称.h</code>中声明方法</li><li>在<code>类名 + 分类名称.m</code>中实现方法</li></ul><!--第四: 回到最开始收集页面启动时间的问题，本类是系统的类，这里是UIViewController，我们可以使用分类扩展他的方法，也可以重写他的方法，可以我需要在调用的地方加头文件，所有子类都写头文件和直接在子类写方法没有什么区别，怎么样可以使得不写头文件，子类就能调用我们写的代码呢？回答：我们可以进行方法交换（这样可以不必在调用的地方增加头文件），从而使得在实现的时候调用重写的方法。具体实现以后会写，TODO--><h5 id="分类的执行优先级"><a href="#分类的执行优先级" class="headerlink" title="分类的执行优先级"></a>分类的执行优先级</h5><ul><li>在本类和分类有相同的方法时，优先调用分类的方法再调用本类的方法。</li><li>如果有两个分类，他们都实现了相同的方法，如何判断谁先执行？分类执行顺序可以通过<code>targets,Build Phases,Complie Source</code>进行调节，注意执行顺序是从上到下的。（只有两个相同方法名的分类）</li></ul><h5 id="分类category和类扩展extension的关系"><a href="#分类category和类扩展extension的关系" class="headerlink" title="分类category和类扩展extension的关系"></a>分类<code>category</code>和类扩展<code>extension</code>的关系</h5><ul><li>类扩展<code>extension</code>是<code>category</code>的一个特例，有时候也被称为匿名分类。他的作用是为一个类添加一些私有的成员变量和方法。</li><li>类扩展能写点啥？和分类不同，类扩展即可以声明成员变量又可以声明方法。</li><li>类扩展听上去很复杂，但其实我们很早就认识他了。你记得继承自<code>UIViewController</code>的<code>ViewController</code>和继承自<code>NSObject</code>的类有什么不同么？<br>继承自<code>UIViewController</code>的<code>ViewController</code>类,对比看一下继承自<code>NSObject</code>的类我们会发现没有下面的代码块<br>  <code>@interface ViewController()</code><font color="#006600">&emsp;&emsp;//这就是类扩展的写法</font><br> <code>@end</code></li><li>类扩展可以定义在<code>.m</code>文件中，这种扩展方式中定义的变量都是私有的，也可以定义在<code>.h</code>文件中，这样定义的代码就是共有的，类扩展在<code>.m</code>文件中声明私有方法是非常好的方式。</li><li>类扩展中添加的新方法，一定要实现,<code>category</code>中没有这种限制。</li></ul>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> 技术细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>简介</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>参加过多个产品的设计,交互,技术定型,开发,发布等完成的开发流程.具有快速学习的能力和沟通能力，能够快速融入团队,喜欢钻研新技术，更把新技术完美运用到项目中为乐趣,对工作和生活有很强的责任心,认真对待做的每一件事情.</p><h4 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h4><p> 邮箱: zjm100163@163.com</p>]]></content>
    </entry>
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
